{
    "Books?": {
        "title": "Books?",
        "score": 2,
        "url": "https://www.reddit.com/r/cpp_questions/comments/1dr8v4d/books/",
        "content": "In C there is some good books which are highly rated and updated like \"The C Programming Language\" and \"C Programming: a modern approach\". On the other hand i did a little bit of research on c++ books but i found that everyone is disagreeing about which books are good which made me really confused. Any help about some good books and why people hate all of them would be appreciated. ",
        "num_comments": 11,
        "comments": [
            "+1 on learncpp.com, I'm doing it right now and it's very good.\n\nAnyway, to really help you, we need to know more about you. Have you programmed much before? Do you have a strong C background? What's your goal / learning timeline?",
            "I'm not sure I'd agree that old books are hated. Meyer's *Effective* series and Sutter's *Exceptional* series (and many others) are still very valuable and well liked today. The only real complaint is that the syntax has moved on; so we don't use `std::auto_ptr` any more or get a pointer to vector storage through `&vec[0]`. And that's fair; but the actual ideas the properly good books teach do remain well worth knowing.",
            "Oh, i didn't know that mb, but c doesn't change much anyways right? So what books are not \"hated\"??",
            "Yeah, i have kind of programmed before did  cs50x. Which made me fall in love with c and python while growing my hatred towards web programming. I saw that most performance apps used cpp and c was mostly used in embedded . About my c background, i think i have all the fundamentals down. i even understand pointers and dsa. My goal is to become a developer for anything that needs performance. I love squeezing every last drop of performance from code. But other than that idrk im nearly 15 and haven't really experienced the world. i just wanna learn what i love.",
            "Thank you, kind sir. i will check it out.",
            "I will echo that learncpp.com is an excellent tutorial to learn from. But if you prefer an old paper book then that's the list of the good ones.",
            "\"The C Programming Language\" was updated in 1988. :-) \n\nC++ has the \"problem\" that it nowadays is revised every 3 years, and nobody seems to want to rewrite their book that often.\n\nSo books that were really good 20 years ago, are now \"hated\" because they teach C++98, an ancient version.",
            "the c++ programming language",
            "Here is the [definitive list](https://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list)",
            "There's a book list linked in the sidebar. Also just hop on https://www.learncpp.com/ and start writing code."
        ]
    },
    "Can't include the bcrypt library on windows in VS project": {
        "title": "Can't include the bcrypt library on windows in VS project",
        "score": 1,
        "url": "https://www.reddit.com/r/cpp_questions/comments/1drbxjw/cant_include_the_bcrypt_library_on_windows_in_vs/",
        "content": "I'm new to programming and C++ and have never used anything but the standard tools, so I might do something wrong\n\nLibrary: [https://github.com/trusch/libbcrypt](https://github.com/trusch/libbcrypt)  \nError LNK2019 and LNK1120\n\nAfter downloading git and cmake I entered the commands as in instruction, \"make\" command didn't work, I asked AI and replaced with \"cmake --build .\", also tried building the project manually. Next, In the build/debug i found .lib next to .exe (.exe file with the hashing example works fine), I connected this .lib file to my project in Visual Studio through the project settings according to the guides, additionally I entered into the code #pragma comment(lib, \"blahblah/bcrypt.lib\"). \n\nBut none of the actions had any effect on anything, it's just the same error. What should I do? ",
        "num_comments": 0,
        "comments": []
    },
    "Confused about Folly's implementation on RCU": {
        "title": "Confused about Folly's implementation on RCU",
        "score": 2,
        "url": "https://www.reddit.com/r/cpp_questions/comments/1dr7m0f/confused_about_follys_implementation_on_rcu/",
        "content": "Hello, recently I've been intrigued by this [post](https://www.reddit.com/r/cpp/comments/1dppjkk/will_you_use_c26_rcu_library/) in particular and have been reading up on RCU. However, I am currently looking through the implementation of RCU in Folly (specifically [this implementation](https://github.com/facebook/folly/blob/main/folly/synchronization/Rcu.h)).\n\nIn particular, I am confused about [this section](https://github.com/facebook/folly/blob/main/folly/synchronization/Rcu.h#L371-L393). I believe that the current implementation uses Epoch-Based Reclamation and `half_sync(...)` is just to increment the current epoch (`version_`) and perform reclamation on those memory associated with `epoch - 2`(If we consider the value increment at the end the current epoch). However, the comment in the `retire`function confuses me. It states the following:\n\n>Note that it's likely we hold a read lock here, so we can only `half_sync(false)`.  `half_sync(true)` or a `synchronize()` call might block forever.\n\nI don't see how `retire` could deadlock if we choose `half_sync(true)` or `synchronize()` instead, so any insights around this issue would be much appreciated.\n\nEdit: Formatting.",
        "num_comments": 0,
        "comments": []
    },
    "Project Suggestions": {
        "title": "Project Suggestions",
        "score": 3,
        "url": "https://www.reddit.com/r/cpp_questions/comments/1dr57se/project_suggestions/",
        "content": "Can y'all suggest any basic and beginner-friendly text based projects I can do to test my skill.",
        "num_comments": 4,
        "comments": [
            "1. Word counter (wc command on Linux).  \n2. If you know how to interact with the terminal, you can make a Greedy Sneak game in pure text in the terminal.",
            "this is a GOLDMINE!! Holy, thanks mate!!",
            "For a first project that shouldn't suck up too much time, [commandline connect four](https://www.reddit.com/r/cpp_questions/comments/hee87r/any_ideas_for_a_c_project_to_write_in_3_hours/fvqrrmr/).",
            "What's the reason why you want to learn C++? What program do you want to make? Go make that. Working on something that interests you is always better than just doing some random tasks which you'll drop after a few days because you're not invested.\n\nBut here are some ideas, pick whatever you deem interesting or come up with your own ones:\n\n* https://github.com/codecrafters-io/build-your-own-x\n* https://jamesmcm.github.io/blog/programming-projects/\n* https://github.com/florinpop17/app-ideas\n* https://github.com/practical-tutorials/project-based-learning\n* https://projectbook.code.brettchalupa.com/_introduction.html\n* https://codingchallenges.fyi/challenges/intro/"
        ]
    },
    "Cleaning up memory... I just suck at it.": {
        "title": "Cleaning up memory... I just suck at it.",
        "score": 2,
        "url": "https://www.reddit.com/r/cpp_questions/comments/1dr6jst/cleaning_up_memory_i_just_suck_at_it/",
        "content": "I am working on a problem that requires to sort a graph topologically. I understand the theory behind graphs & sorting & such and I am stuck at the implementation. It's required to be in C++.\n\nI am also using CLion, which pointed that one of my methods has a problem with memory leaks. I've completed a C++ course last year, but I haven't practiced it at all. Memory management is so hard for me to understand.\n\nHere's my code so far:\n\n**Graph.h**\n```\nstruct AdjacentNode {\n    int vertex, cost;\n    AdjacentNode *next;\n};\n\nstruct GraphEdge {\n    int from, to, weight;\n};\n\n\nclass DirectedGraph {\n    int number_of_vertices;\n\n    static AdjacentNode *insert_node(AdjacentNode *adjacent_node, int value, int weight);\n\npublic:\n    AdjacentNode **adjacency_list;\n\n    DirectedGraph(GraphEdge edges[], int number_of_edges, int number_of_vertices);\n\n    ~DirectedGraph();\n};\n```\n\n**Graph.cpp**\n```\n#include \"Graph.h\"\n\nAdjacentNode *DirectedGraph::insert_node(AdjacentNode *adjacent_node, const int value, const int weight) {\n    auto *new_node = new AdjacentNode;\n    new_node->vertex = value;\n    new_node->cost = weight;\n    new_node->next = adjacent_node;\n    return new_node;\n}\n\nDirectedGraph::DirectedGraph(GraphEdge edges[], const int number_of_edges, const int number_of_vertices) {\n    adjacency_list = new AdjacentNode *[number_of_vertices]();\n    this->number_of_vertices = number_of_vertices;\n\n    for (int i = 0; i < number_of_vertices; ++i) {\n        adjacency_list[i] = nullptr;\n    }\n\n    for (int i = 0; i < number_of_edges; i++) {\n        const int start = edges[i].from;\n        const int end = edges[i].to;\n        const int weight = edges[i].weight;\n\n        AdjacentNode *new_node = insert_node(adjacency_list[start], end, weight);\n        adjacency_list[start] = new_node;\n    }\n}\n\n\nDirectedGraph::~DirectedGraph() {\n    for (int i = 0; i < number_of_vertices; i++) {\n        delete[] adjacency_list[i];\n    }\n    delete[] adjacency_list;\n    adjacency_list = nullptr;\n}\n```\n\nIn my destructor, as you can see, I've called `delete[] adjacency_list[i]` for each vertex I have and delete on the adjacency list itself. However I am stuck at how to call delete[] each AdjacentNode I create in `insert_node`.\n\nAny help is appreciated!",
        "num_comments": 9,
        "comments": [
            "Unless you're learning the language/algorithms, don't use new and delete. Use smart pointers and stl containers.\n\nIf you really want to stick with new and delete, you have to start thinking really hard about object lifespans. As soon as you write 'new,' you should *immediately* write a corresponding 'delete' that you *know* will be called at some point to destroy it. And set reusable pointers to nullptr when the memory is deleted.",
            "Using \"new\" is generally considered bad practice these days, outside of certain contexts, because you are setting yourself up to fail. If you don't manually clean up your memory, you have a memory leak.\n\nYou can almost completely avoid the need for manual memory management by using smart pointers. They are a fairly complex topic in their own right for someone who isn't used to C++, but they are more than worth the investment of effort and you will write *much* safer code if you embrace them. It is hard to write a memory leak in modern C++.",
            "In order to represent a graph I would have a std:: vector of nodes, and use indices instead of pointers. It's much easier to get the code right and the performance is probably better because of better memory locality (I say \"probably\" because performance is very hard to predict and statements about something being faster than something else should always be based on empirical evidence.)",
            "I don\u2019t see a delete method, so make the nodes use an arena allocator and free the arena allocator in the graph destructor (assuming the nodes are trivially destructible).",
            "stl containers >>> unique_ptr >>>>> shared_ptr (probably should refactor the code) >>>>>>>> new/delete.\n\ni\u2019ve seen so much code where people just replace all of their new/delete (a lot of them allocated every single object dynamically) with shared_ptr because people told them to \"always use smart pointers\".",
            "It's all part of learning",
            "For one thing, if it is `new` (without `[]`) it should also be `delete` (without `[]`).\n\nNot sure if that is what the compiler sees as a problem.\n\nAnyway, I have a personal problem with a static member creating objects of a different type. I would have expected that other type to have a constructor for this.",
            "You don't suck, you're learning. I would use shared_ptr from the start and call it a day. I will always check against a nullptr so I have that branch at hand anyways.\n\nI never encountered a problem in which that is a real performance issue. But that's me. My codes tend to be about what I do with my data than accessing that data to do some basic operations. Profile your code and see if this suits you.\n\nSince you're trying to implement a data structure, you may need to squeeze more performance than me though. In that case, you can write up some unit tests to be (almost) sure your data structure is not leaking.\n\nJust for reference, my \"slowest\" code was doing about 250k physical simulations. Since I am delegating the simulation part to MATLAB, my optimisation code in C++ is not the bottleneck. I am talking about 10hrs of simulation vs half an hour optimisation. And the optimisation part can be improved with a better algorithm resulting in less simulations instead of a faster algorithm.",
            "Your posts seem to contain unformatted code. Please make sure to format your code otherwise your post may be removed.\n\nIf you wrote your post in the \"new reddit\" interface, please make sure to format your code blocks by putting four spaces before each line, as the backtick-based (```) code blocks do not work on old Reddit.\n\n\n*I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp_questions) if you have any questions or concerns.*"
        ]
    }
}
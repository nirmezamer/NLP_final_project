{
    "Cleaning up memory... I just suck at it.": {
        "title": "Cleaning up memory... I just suck at it.",
        "score": 1,
        "url": "https://www.reddit.com/r/cpp_questions/comments/1dr6jst/cleaning_up_memory_i_just_suck_at_it/",
        "content": "I am working on a problem that requires to sort a graph topologically. I understand the theory behind graphs & sorting & such and I am stuck at the implementation. It's required to be in C++.\n\nI am also using CLion, which pointed that one of my methods has a problem with memory leaks. I've completed a C++ course last year, but I haven't practiced it at all. Memory management is so hard for me to understand.\n\nHere's my code so far:\n\n**Graph.h**\n```\nstruct AdjacentNode {\n    int vertex, cost;\n    AdjacentNode *next;\n};\n\nstruct GraphEdge {\n    int from, to, weight;\n};\n\n\nclass DirectedGraph {\n    int number_of_vertices;\n\n    static AdjacentNode *insert_node(AdjacentNode *adjacent_node, int value, int weight);\n\npublic:\n    AdjacentNode **adjacency_list;\n\n    DirectedGraph(GraphEdge edges[], int number_of_edges, int number_of_vertices);\n\n    ~DirectedGraph();\n};\n```\n\n**Graph.cpp**\n```\n#include \"Graph.h\"\n\nAdjacentNode *DirectedGraph::insert_node(AdjacentNode *adjacent_node, const int value, const int weight) {\n    auto *new_node = new AdjacentNode;\n    new_node->vertex = value;\n    new_node->cost = weight;\n    new_node->next = adjacent_node;\n    return new_node;\n}\n\nDirectedGraph::DirectedGraph(GraphEdge edges[], const int number_of_edges, const int number_of_vertices) {\n    adjacency_list = new AdjacentNode *[number_of_vertices]();\n    this->number_of_vertices = number_of_vertices;\n\n    for (int i = 0; i < number_of_vertices; ++i) {\n        adjacency_list[i] = nullptr;\n    }\n\n    for (int i = 0; i < number_of_edges; i++) {\n        const int start = edges[i].from;\n        const int end = edges[i].to;\n        const int weight = edges[i].weight;\n\n        AdjacentNode *new_node = insert_node(adjacency_list[start], end, weight);\n        adjacency_list[start] = new_node;\n    }\n}\n\n\nDirectedGraph::~DirectedGraph() {\n    for (int i = 0; i < number_of_vertices; i++) {\n        delete[] adjacency_list[i];\n    }\n    delete[] adjacency_list;\n    adjacency_list = nullptr;\n}\n```\n\nIn my destructor, as you can see, I've called `delete[] adjacency_list[i]` for each vertex I have and delete on the adjacency list itself. However I am stuck at how to call delete[] each AdjacentNode I create in `insert_node`.\n\nAny help is appreciated!",
        "num_comments": 1,
        "comments": [
            "Your posts seem to contain unformatted code. Please make sure to format your code otherwise your post may be removed.\n\nIf you wrote your post in the \"new reddit\" interface, please make sure to format your code blocks by putting four spaces before each line, as the backtick-based (```) code blocks do not work on old Reddit.\n\n\n*I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/cpp_questions) if you have any questions or concerns.*"
        ]
    },
    "Looking for a book/tutorial about software development in C++ with a real example": {
        "title": "Looking for a book/tutorial about software development in C++ with a real example",
        "score": 10,
        "url": "https://www.reddit.com/r/cpp_questions/comments/1dqs57h/looking_for_a_booktutorial_about_software/",
        "content": "Hey everyone. I've learnt some basic C++ and now I'm looking for a book/course/tutorial about making a real software. I'm looking for something rather complex, showing design patterns, programming principles, additional instruments & libraries and etc, being used in a real project, so I can at least vaguely see, what professional programming looks like. People usually advice to check out some open-source projects, but I don't feel that confident yet and I'd like to see something being written from scratch and with explanations. Thanks in advance!\n\n",
        "num_comments": 7,
        "comments": [
            "[https://github.com/codecrafters-io/build-your-own-x](https://github.com/codecrafters-io/build-your-own-x) check the C++ section. Other than that there are a few books with names like \".. design and implementation\" which usually guide you through building whatever the book is about.",
            "Don't know whether it has any larger examples/projects but [Professional C++, 6th Edition](https://www.wiley.com/en-us/Professional+C%2B%2B%2C+6th+Edition-p-9781394193172) covers a bit more about thr design and engineering part of programming than the usual introduction texts.",
            "Books are normally out of date. Google \"github c++ cmake beginner\"",
            "Thank you so much for this. So useful\u00a0",
            "OMG what a nice source! Thank you, this is gonna be useful",
            "Yep, but I guess I still can learn something from them, unless they're not from noughties. I already tried using cmake and when I was struggling with compiling a library, I also learned about conan. They're pretty useful, but again, it'd be nice if there was a tutorial of the kind I described :D",
            "Yes i agree yoy can. But most \"large\" sw companies use thier own tools i.e cmakr/make, conan/vcpkg.... i think most of them are using the first choise... and git. Cmake is a tool as are the other names i dropped. You need to pick your tools, you can lear others, same with vim/clion/vscode...."
        ]
    },
    "Project Suggestions": {
        "title": "Project Suggestions",
        "score": 1,
        "url": "https://www.reddit.com/r/cpp_questions/comments/1dr57se/project_suggestions/",
        "content": "Can y'all suggest any basic and beginner-friendly text based projects I can do to test my skill.",
        "num_comments": 3,
        "comments": [
            "What's the reason why you want to learn C++? What program do you want to make? Go make that. Working on something that interests you is always better than just doing some random tasks which you'll drop after a few days because you're not invested.\n\nBut here are some ideas, pick whatever you deem interesting or come up with your own ones:\n\n* https://github.com/codecrafters-io/build-your-own-x\n* https://jamesmcm.github.io/blog/programming-projects/\n* https://github.com/florinpop17/app-ideas\n* https://github.com/practical-tutorials/project-based-learning\n* https://projectbook.code.brettchalupa.com/_introduction.html\n* https://codingchallenges.fyi/challenges/intro/",
            "1. Word counter (wc command on Linux).  \n2. If you know how to interact with the terminal, you can make a Greedy Sneak game in pure text in the terminal.",
            "this is a GOLDMINE!! Holy, thanks mate!!"
        ]
    },
    "How do you Build/Compile the X11 Library": {
        "title": "How do you Build/Compile the X11 Library",
        "score": 1,
        "url": "https://www.reddit.com/r/cpp_questions/comments/1dr46iy/how_do_you_buildcompile_the_x11_library/",
        "content": "Hello, I am learning how to compile/build programs. \n\nDoes anyone know how to use the X11 libraries in C++/C ? \n\n    g++ -L robot-master/Binaries/Linux/libRobot.a main.cpp -lRobot\n    /usr/bin/ld: /usr/lib/gcc/x86_64-linux-gnu/11/../../../../lib/libRobot.so: undefined reference to `XScreenOfDisplay'\n    /usr/bin/ld: /usr/lib/gcc/x86_64-linux-gnu/11/../../../../lib/libRobot.so: undefined reference to `XGetImage'\n    /usr/bin/ld: /usr/lib/gcc/x86_64-linux-gnu/11/../../../../lib/libRobot.so: undefined reference to `XTestQueryExtension'\n    /usr/bin/ld: /usr/lib/gcc/x86_64-linux-gnu/11/../../../../lib/libRobot.so: undefined reference to `XScreenNumberOfScreen'\n    /usr/bin/ld: /usr/lib/gcc/x86_64-linux-gnu/11/../../../../lib/libRobot.so: undefined reference to `XSendEvent'\n    /usr/bin/ld: /usr/lib/gcc/x86_64-linux-gnu/11/../../../../lib/libRobot.so: undefined reference to `XGetWindowProperty'\n    /usr/bin/ld: /usr/lib/gcc/x86_64-linux-gnu/11/../../../../lib/libRobot.so: undefined reference to `XSetErrorHandler'\n    /usr/bin/ld: /usr/lib/gcc/x86_64-linux-gnu/11/../../../../lib/libRobot.so: undefined reference to `XQueryExtension'\n    /usr/bin/ld: /usr/lib/gcc/x86_64-linux-gnu/11/../../../../lib/libRobot.so: undefined reference to `XQueryTree'\n    /usr/bin/ld: /usr/lib/gcc/x86_64-linux-gnu/11/../../../../lib/libRobot.so: undefined reference to `XIconifyWindow'\n    /usr/bin/ld: /usr/lib/gcc/x86_64-linux-gnu/11/../../../../lib/libRobot.so: undefined reference to `XKeysymToKeycode'\n    /usr/bin/ld: /usr/lib/gcc/x86_64-linux-gnu/11/../../../../lib/libRobot.so: undefined reference to `XDefaultScreen'\n    /usr/bin/ld: /usr/lib/gcc/x86_64-linux-gnu/11/../../../../lib/libRobot.so: undefined reference to `XineramaQueryScreens'\n    /usr/bin/ld: /usr/lib/gcc/x86_64-linux-gnu/11/../../../../lib/libRobot.so: undefined reference to `XInternAtom'\n    /usr/bin/ld: /usr/lib/gcc/x86_64-linux-gnu/11/../../../../lib/libRobot.so: undefined reference to `XScreenCount'\n    /usr/bin/ld: /usr/lib/gcc/x86_64-linux-gnu/11/../../../../lib/libRobot.so: undefined reference to `XSetInputFocus'\n    /usr/bin/ld: /usr/lib/gcc/x86_64-linux-gnu/11/../../../../lib/libRobot.so: undefined reference to `XChangeProperty'\n    /usr/bin/ld: /usr/lib/gcc/x86_64-linux-gnu/11/../../../../lib/libRobot.so: undefined reference to `XineramaIsActive'\n    /usr/bin/ld: /usr/lib/gcc/x86_64-linux-gnu/11/../../../../lib/libRobot.so: undefined reference to `XConfigureWindow'\n    /usr/bin/ld: /usr/lib/gcc/x86_64-linux-gnu/11/../../../../lib/libRobot.so: undefined reference to `XQueryPointer'\n    /usr/bin/ld: /usr/lib/gcc/x86_64-linux-gnu/11/../../../../lib/libRobot.so: undefined reference to `XRaiseWindow'\n    /usr/bin/ld: /usr/lib/gcc/x86_64-linux-gnu/11/../../../../lib/libRobot.so: undefined reference to `XHeightOfScreen'\n    /usr/bin/ld: /usr/lib/gcc/x86_64-linux-gnu/11/../../../../lib/libRobot.so: undefined reference to `XTestFakeButtonEvent'\n    /usr/bin/ld: /usr/lib/gcc/x86_64-linux-gnu/11/../../../../lib/libRobot.so: undefined reference to `XQueryKeymap'\n    /usr/bin/ld: /usr/lib/gcc/x86_64-linux-gnu/11/../../../../lib/libRobot.so: undefined reference to `XTestFakeKeyEvent'\n    /usr/bin/ld: /usr/lib/gcc/x86_64-linux-gnu/11/../../../../lib/libRobot.so: undefined reference to `XFree'\n    /usr/bin/ld: /usr/lib/gcc/x86_64-linux-gnu/11/../../../../lib/libRobot.so: undefined reference to `XTestGrabControl'\n    /usr/bin/ld: /usr/lib/gcc/x86_64-linux-gnu/11/../../../../lib/libRobot.so: undefined reference to `XineramaQueryVersion'\n    /usr/bin/ld: /usr/lib/gcc/x86_64-linux-gnu/11/../../../../lib/libRobot.so: undefined reference to `XOpenDisplay'\n    /usr/bin/ld: /usr/lib/gcc/x86_64-linux-gnu/11/../../../../lib/libRobot.so: undefined reference to `XDefaultRootWindow'\n    /usr/bin/ld: /usr/lib/gcc/x86_64-linux-gnu/11/../../../../lib/libRobot.so: undefined reference to `XWarpPointer'\n    /usr/bin/ld: /usr/lib/gcc/x86_64-linux-gnu/11/../../../../lib/libRobot.so: undefined reference to `XDestroyWindow'\n    /usr/bin/ld: /usr/lib/gcc/x86_64-linux-gnu/11/../../../../lib/libRobot.so: undefined reference to `XRootWindow'\n    /usr/bin/ld: /usr/lib/gcc/x86_64-linux-gnu/11/../../../../lib/libRobot.so: undefined reference to `XTranslateCoordinates'\n    /usr/bin/ld: /usr/lib/gcc/x86_64-linux-gnu/11/../../../../lib/libRobot.so: undefined reference to `XGetInputFocus'\n    /usr/bin/ld: /usr/lib/gcc/x86_64-linux-gnu/11/../../../../lib/libRobot.so: undefined reference to `XGetWindowAttributes'\n    /usr/bin/ld: /usr/lib/gcc/x86_64-linux-gnu/11/../../../../lib/libRobot.so: undefined reference to `XWidthOfScreen'\n    /usr/bin/ld: /usr/lib/gcc/x86_64-linux-gnu/11/../../../../lib/libRobot.so: undefined reference to `XSync'\n    collect2: error: ld returned 1 exit status\n    ",
        "num_comments": 5,
        "comments": [
            "X11 is considered a system library provided by your linux distribution. You typically don't build this (don't know if it's even possible). You probably already have the library on your system, you just need to link it into your program. You do that by adding `-lX11` to the compiler/linker command.",
            "If all that stuff is just in libX11, you probably need to add `-lX11` to your linking command.",
            "> You typically don't build this (don't know if it's even possible).\n\nIt certainly is. But it shouldn't be necessary for what they seem to want to do (which I think is what you're saying anyhow).",
            "Yeah, I mean someone for sure built it to ship it with your distribution, so it's certainly possible.\n\nBut I somehow got the impression that it is integrated with each distribution and there is no stand-alone implementation, but I could be wrong as I can see a source mirror on GitHub. I'm not too knowledgeable about the structure of Linux distributions.",
            "A Linux distro is mostly built from upstream projects, so modern systems running X11 are going to be derived from X.org's implementation, probably modified some by individual distributions for whatever reasons, but they're mostly not using their own custom code. Just custom packaging of the source, building binaries, etc."
        ]
    },
    "In-IDE (CLion) std C++ documentation?": {
        "title": "In-IDE (CLion) std C++ documentation?",
        "score": 1,
        "url": "https://www.reddit.com/r/cpp_questions/comments/1dr444b/inide_clion_std_c_documentation/",
        "content": "Hey all, I'm learning C++, I'm coming from Java/IntelliJ stack. One thing I've taken for granted in Java/IntelliJ is being able to 'jump' into a function (i.e. take me to function definition) for `java.util` (i.e. stdlib equivalent) files and get very clear documentation on what a function does and how to use it. For example, `ArrayList::add` :\n\n    /**\n     * Appends the specified element to the end of this list.\n     *\n     * @param e element to be appended to this list\n     * @return {@code true} (as specified by {@link Collection#add})\n     */\n    public boolean add(E e) ...\n\nWhen I do the same from CLion for a roughy-equivalent example, `vector::emplace_back` this is what I see:\n\n    template <class _Tp, class _Allocator>\n    template <class... _Args>\n    _LIBCPP_CONSTEXPR_SINCE_CXX20\n    inline\n    #if _LIBCPP_STD_VER >= 17\n    typename vector<_Tp, _Allocator>::reference\n    #else\n    void\n    #endif\n    vector<_Tp, _Allocator>::emplace_back(_Args&&... __args)\n    {\n        if (this->__end_ < this->__end_cap())\n        {\n            __construct_one_at_end(std::forward<_Args>(__args)...);\n        }\n        else\n            __emplace_back_slow_path(std::forward<_Args>(__args)...);\n    #if _LIBCPP_STD_VER >= 17\n        return this->back();\n    #endif\n    }\n\nI understand I can find the info I'm looking for on cppreference.com, but this workflow seems less-than-ideal. What's the 'correct' setup/workflow here? Is there a trick I'm missing? Am I looking in the wrong place? Thank you!",
        "num_comments": 3,
        "comments": [
            "No you're not doing anything wrong. It's just that no-one bothered to add documentation to the compiler's stdlib implementation.\n\nWould be nice if one could get cpprererence as a reference implementation in header files with doxygen docstrings, but to my knowledge it doesn't exist.\n\nYou'll unfortunately have to shift back and forth between IDE and browser.",
            "Ack, thanks. I did see CLion at least has an F1 button which opens the relevant cppreference link. Feels like there could be better integration though \ud83e\udd14\n\nAnyway, thanks for confirming I'm not missing something!",
            "Thing is: unlike Java, there isn't just one C++ standard library implementation. Each compiler will typically have their own and you can configure CLion to use any compiler available on your system."
        ]
    }
}
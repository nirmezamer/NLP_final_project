{
    "Why is the junior embedded job market dead": {
        "title": "Why is the junior embedded job market dead",
        "score": 92,
        "url": "https://www.reddit.com/r/embedded/comments/1dqkqbr/why_is_the_junior_embedded_job_market_dead/",
        "content": "Just trying to understand reasons behind it. Is the profession headed towards a steady decline or is something else causing this.",
        "num_comments": 124,
        "comments": [
            "The job market for entry level has been dying for the past 30 years - you\u2019re pretty much seeing the tail end of it.\n\nTo save costs employers have mostly eliminated mentorship and development programs. Now look at productivity metrics - they\u2019ve been steadily rising meaning that companies depend more and more on experienced talent.\n\nWhen they need to replace a very high productivity employee they are stuck in a situation that most executives can\u2019t wrap their head around - try to find a unicorn or train someone.\n\nThat is why you are seeing absurd job postings and no entry level.",
            "In Italy the job market for embedded firmware developers is still alive.",
            "Embedded devs tend to become highly specialized and could monopolize the development of a whole product, as a form of job security. With that mindset, companies end up hiring less embedded (or firmware) engineers",
            "I think a lot of it just has to do with many western economies pumping the brakes to get a handle on inflation. But to be real I remember reading on Reddit about how impossible it was to get a job straight out of college back when I was a junior too and I didn't have any trouble, so take whatever you read on here with a grain of salt.",
            "The job market back in 2008 sucked too for several years sadly. In my experience companies don\u2019t want to train Junior devs anymore they want people to hit the ground running. Which sucks because it\u2019s pulling the ladder up. \n\nBut most of us would like to work with more Junior people (to help us fight against the dinosaurs lol) but corporate hiring dictates a lot of that. Even intern positions seem hit or miss the last 5 years.",
            "Here are the big factors at play in my opinion:  \n- Corporations don't want to train junior embedded developers, the bean counters are gutting teams every way they can.   \n- Embedded is hard, the talent pool is small.  \n- A lot of the junior level work in embedded is being outsourced to china and india.  \n- The bleeding edge of embedded is even harder to get into, so hiring is biased towards seniors.",
            "Job hopping in embedded is more rare than the rest of the software industry. What this means is that as tech has substantially grown in the past ~20 years, a lot of the major companies have become top heavy. \n\nThis brings about two scenarios. The first is that growing companies only want to poach highly skilled devs and they can usually pay well for it. The second is that the more established companies have little to no desire to train junior devs and I just don\u2019t think these companies have realized how much of an impact this may have. This is particularly because the devs that were around for the turn of the millenium are still working today, so everything will operate well until they decide to leave. \n\nThis is just my two cents as someone who has done embedded dev at 2 large US chip manufacturers.",
            "I saw it differently from you guys. I figured embedded was one of the first specializations you could get after 3-5 years in a related engineering job. I thought these jobs were for mid to senior level engineers and then something like RF or Semiconductors was pretty much exclusive to phds. RF and Semiconductors focused jobs don't usually have Junior roles do they?",
            "That's why I never applied for junior position.  \n\nI am Linux DevOps, I do this for a living. But I also write A LOT of code in my spare time and I do a lot of RTOS and Yocto. It's fun!  \n\nSo I am able to earn money working full time job and get better at embedded because of that steady cash income.  \n\nWhen I wanted to try how does the real world work, I applied for Mid position at Hitachi Energy. ARM, Yocto, C and some C++ - the dream stack.  \nGetting the job was easy, contract was for fixed 6 months time, I loved every single minute there.  \n\nNow I repeat this every year and I've got the best of both worlds.",
            "Two parts to this:\n\n1. Avoiding \"junior\" type jobs as part a general weird thing in the hiring side of the market where they just want to pretend the job market starts at like 3-5 years of experience.  (This might also relate to farming out the more basic jobs to near and offshore job markets.)\n2. The current slowness in the tech and near tech hiring markets.  This means there are fewer jobs for the pool of candidates which presumably is the same size as before.  So if you have 50 jobs instead of 75 jobs but you still have 100 people seeking those jobs, you have a tighter job market.\n\nThere's no fix for 1 outside of larger job market changes (this doesn't relate to only tech jobs, but any job that's not nursing/nursing adjacent.)\n\nPart 2 will be fixed in the near-term, but near term could be 2-3 years, but I know at least some companies we're already having to reopen hiring.  Pausing hiring for 2 years is dumb and always causes more problems than it fixes, but it is what it is.  Even if I have a pocket book with cash in it, HR still gets to magically tell me \"no\"."
        ]
    },
    "I\u2019m lost on where to go after blinking an LED (teaching myself STM32)": {
        "title": "I\u2019m lost on where to go after blinking an LED (teaching myself STM32)",
        "score": 13,
        "url": "https://www.reddit.com/r/embedded/comments/1dqyarp/im_lost_on_where_to_go_after_blinking_an_led/",
        "content": "I\u2019m currently teaching myself embedded the summer before I take a course in it in the fall. My goal is to make the class easier and potentially get a project up and running for my fall career fair. I am using an STM32 Nucleo.\n\nWith the amount of resources online, I\u2019m lost on where to go. It feels like every online resource teaches you how to blink an LED and then it makes a huge jump to complicated things I do not understand. Or it shows how to do something without explaining WHY I\u2019m doing it.\n\nI tried messing around with UART protocol. I understand how it works at a physical level, but I can\u2019t get a single peripheral working in practice. I feel like I\u2019m skipping far too many fundamental steps. ",
        "num_comments": 9,
        "comments": [
            "When I was in school, once I learned about using GPIO to blink an LED, I learned about polling and interrupts. I learned about how to constantly poll the processor checking to see if a button was pressed and turning on an LED based on that. Afterwards, learning about interrupts and writing my first ISR and comparing the pros and cons of both polling and interrupts. Also, working with buttons gets you some exposure into bouncing and how you need to write some code that helps alleviate bouncing through debouncing. Personally, I think that would be a next good step. It\u2019s nothing crazy but at the same time, it\u2019s something new as well. \n\nThe STM32 Nucleo has a button and some LEDs as well so you could try creating a program that alternates between different LEDs on the board when a button is pressed\n\n\nEdit: You could jump into communication protocols as well. If you do, I would recommend starting with something a little more simple than UART such as SPI.",
            "This book really helped me:  \n[https://leanpub.com/mastering-stm32-2nd](https://leanpub.com/mastering-stm32-2nd)",
            "For UART, the base STM32 UART pins are connected to the USB pins with a built in UART to USB bridge, therefore in combination with the HAL commands you can just write straight out to USB serial to read on a COM port. default baud i think is 115200. In terms of tutorials etc [https://deepbluembedded.com/](https://deepbluembedded.com/) is great. \n\nFor projects, it all depends on what you are intrested in. If you wanted to do more communications you could set up I2C with some eeproms and use the Low level libraries to learn that way. If youre intrested in motors you can use the PWM out feature with a drive board and then read the encoder signal in using interrupt capture on the STM Timer peripherals. \n\nIf you like instrumentation setting the ADC's up to take sensor measurements.   \nYou can do some cool DSP on the STM32's now too with their built in floating point unit so you could make yourself a little voice modulator with an off the shelf audio codec board. \n\n(Im probably missing tons of ideas)\n\nWhat you can do with a microcontrolller is so vast it really is up to you. think of it like a sandbox game, the blinking LED is the tutorial of the controls now its up to you to explore and build what you want.",
            "Arduino shields.\n\nMake the connection between the connector pins on an STM32 Nucleo and the wide variety of Arduino shields from Adafruit, Sparkfun, etc. Do you want to interface a motor control, an LCD display, etc? Have a blast, I sure did!",
            "Some ideas:\n\nA) RCC abuse - mess with your clock settings and see when it stops being stable and thermally problematic.\n\nB) bit bang spi or I2C ( even if you have the peripherals it's a good exercise to understand the protocols)\n\nC) Try freeRTOS, see what need os it solving and get a feel for when it's more hassle than not.\n\nD) talk to an SD card and implement a filesystem, it's surprisingly easy to talk to SD cards. ( No spoiler)\n\nE) Burn a few chips. See what happens when you fry the hardware. Specifically IO ports. You'll get to know in greater detail the flow and structure of IO port and know what to expect when you do it for real. Sink some current into it and see how long it takes.\n\nF) If you're using an MCU with DSP instructions try to dig deeper. See what your compiler does for you and what it does not what you try some SIMD operations.\n\nG) Become friends with DMA, he's your friend, when he's not trying to kill you. Seriously, try and make some data trains and chain DMA together, it's a useful tool.",
            "Have you tried interfacing your MCU to a terminal? If not, try that. Write a CLI parser/engine with a few commands like: \n- set led on\n- set led on for duration \n- set led off \n- blink led\n- read hardware ID\n- read hardware version\n- read software version",
            "You can try to utilize several peripherals to train.\n\nADC to measure sensors.\n\nSPI and I2C to talk to sensors with some kind of protocol (check their datasheet, they often have a command set and sometimes even internal registers which you can use)\n\nTimers to pace your system (for example: read a sensor at 10Hz). Or timers to measure a time delay, a PWM duty cycle, or output a PWM to some actuator.\n\nDAC to set an analog voltage (if your STM32 has this)\n\nUART to have a classic serial comms to interface with PC.\n\nThere are generally 2 ways to program STM32: via HAL or bare metal.\n\nFor HAL, you could use STM32CubeMX code generator to set up the peripheral, and then find the relevant HAL functions. If you don't wnat to use CubeMX, You could also try to find the peripheral Handle typedef it self, instantiate it, and fill the relevant initialization values. A tutorial can help a great deal with this. Imagine that most of this is boilerplate code though, it's just setting things up the way you need a peripheral to work, but not really using it yet. So this would be step 2: figure out what the peripheral should do, and how the HAL exposes this to you. Typically you can choose between several methods to work with a peripheral, for example blocking calls, interrupt callbacks or even DMA.\n\nFor baremetal, it's a lot more involved. You'll need to open the reference manual to find the control registers, prefill all values, then turn peripheral on, and then make things move via data registers and status registers. As I said its more involved and not a great place to start.\n\nIn both cases, it's always good to check if the relevant clock enable bits in the RCC peripheral are set. Those kind of mistakes can make you pull your hair out when things should work but they don't.",
            "I attempted a project (my previous post in this sub if you\u2019re interested), but I ran into so many roadblocks that I\u2019m backtracking a bit to teach myself the fundamentals. It was just a keypad, UART LCD, and some extra logic to make a number base converter calculator. I\u2019m going to find something a bit simpler.",
            "Caveat to point C, I would think it\u2019s better to write your own RTOS (at least a simple round robin or something) before using FreeRTOS. \n\nTo be fair, I\u2019m not a big fan of FreeRTOS in general, so I might be biased.\n\nAlso, for G, second this hard. If you can do it with DMA, try doing it using DMA"
        ]
    },
    "TIMXCLK F1 Series": {
        "title": "TIMXCLK F1 Series",
        "score": 3,
        "url": "https://i.redd.it/3ztp0mq3zf9d1.jpeg",
        "content": "I\u2019m trying to figure out this clock tree for TIM7. So let\u2019s say SYSCLK ends up being 72MHz and the AHB prescaler is 1 and then I set my APB1 prescaler to 2 to follow the 36MHz frequency limit on the APB1 bus then I see that it splits to the AND gate for PCLK1 and then there is a path where it goes to pertain to TIM 2, 3, 4  and it says if APB1 prescaler is 1 then x1 else x2 and it leads to TIMXCLK. A couple confusions I have up to the point:\n- I thought that all peripherals of a bus get their clocks derived from the bus frequency, so I\u2019m confused why TIM 2, 3, 4 split to TIMXCLK when they\u2019re part of APB1 bus\n\n- the tree only lists this for TIM2, 3, 4 but TIM2-7 is on the APB1 bus for my MCU aswell, does this mean  this only pertains to specifically 2,3,4? Or is it just shortened\n\n- if they are different (PCLK and TIMXCLK) wouldn\u2019t my TIMXCLK become 72MHz since the prescaler is not 1 so 36MHz is doubled, is this allowed since it\u2019s part of the APB1 bus and the max is 36MHz\n\nI\u2019m confused, any help would be greatly appreciated, thank you!!!",
        "num_comments": 1,
        "comments": [
            "I am guessing that the timers can run on 72MHZ input clock, you are right about the multiplication of 2 from the schematic.\n\nWhat does the reference manual say? How about the datasheet?"
        ]
    },
    "Embedded Software Mock Interviews Platforms": {
        "title": "Embedded Software Mock Interviews Platforms",
        "score": 5,
        "url": "https://www.reddit.com/r/embedded/comments/1dr0n2o/embedded_software_mock_interviews_platforms/",
        "content": "Hello Embedded Enthusiasts,\n\nI am a recent graduate currently on the lookout for a new job since January. Unfortunately, the job market has been quite challenging for freshers like myself. Although I've had some promising interviews, I haven't been able to secure a position.\n\nTo improve my chances, I'm seeking platforms where I can practice embedded systems-related interview questions. I recently came across 'Interview Kickstart', but their pricing is well beyond my budget\u2014they charge $1800 for six mock interviews, which seems quite steep.\n\nCould you suggest more affordable platforms or resources for practicing embedded systems interview questions? Your recommendations would be greatly appreciated!",
        "num_comments": 2,
        "comments": [
            "The best way to learn interviewing skills is to interview. Don't think of an interview like an exam to get a grade. Think of it as a date where you get to  meet people and see if you'd like to work with them. Just be honest and confident. That's what makes you attractive!",
            "I know there's Pramp for general software development. I'm not aware of any embedded specific places. And yeah, I wouldn't pay $1800 for 6 mock interviews. Are you sure this doesn't include some kind of training or counseling?"
        ]
    },
    "What do you use when you want synchronous communication between embedded software and a computer program?": {
        "title": "What do you use when you want synchronous communication between embedded software and a computer program?",
        "score": 4,
        "url": "https://www.reddit.com/r/embedded/comments/1dqx0ss/what_do_you_use_when_you_want_synchronous/",
        "content": "When you want to write a computer program that will communicate synchronously with an embedded system, what do you use as a schedular and other things like communication protocol in the embedded code and what tools or software do you use on the computer side?",
        "num_comments": 10,
        "comments": [
            "Today on loaded questions without enough requirements described:\n\nthe answer is yes.",
            "What do you mean by synchronous communication? Depending on the level of the stack that can mean very different things. Do you have an example protocol, timing requirements, amount of data you are transferring and how often?",
            "Depends on so many variables.. serial, usb, ethernet, wi-fi, can, bluetooth, pcie..",
            "Okay, people are being difficult. I don't need specs to answer this.\n\nI usually make my own serial protocol suited for the occasion: Simple start condition, length, message and CRC. Mostly i use serial com with an ftdi USB driver. If i need fast communication I tune the usb latency down and make the communication without fixed interval, otherwise for convenience to debugging i use fixed intervals.",
            "What is the exact use case? Like speed, reliability etc.\n\n\nWhy do you need a scheduler for communication? Does it mean like messages sent at regular intervals?",
            "\"synchronous\"? I think the word you're looking for is \"low latency\" and what I use depends on what \"low\" means in a particular context and the PC is supposed to do with the data.",
            "What part exactly needs to be synchronous? The program or the comms interface?\n\nFor the latter; there isn't really anything plug'n'play for desktop PCs. On a SBC you could I2C or SPI.\n\nIf you talk about computing in general, that sounds more of a real-time requirement, and best not to be solved with general purpose computing hardware.",
            "UART every day",
            "With special guest: OP who doesn't reply to questions",
            "That's asynchronous though"
        ]
    }
}
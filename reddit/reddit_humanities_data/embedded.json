{
    "I\u2019m lost on where to go after blinking an LED (teaching myself STM32)": {
        "title": "I\u2019m lost on where to go after blinking an LED (teaching myself STM32)",
        "score": 25,
        "url": "https://www.reddit.com/r/embedded/comments/1dqyarp/im_lost_on_where_to_go_after_blinking_an_led/",
        "content": "I\u2019m currently teaching myself embedded the summer before I take a course in it in the fall. My goal is to make the class easier and potentially get a project up and running for my fall career fair. I am using an STM32 Nucleo.\n\nWith the amount of resources online, I\u2019m lost on where to go. It feels like every online resource teaches you how to blink an LED and then it makes a huge jump to complicated things I do not understand. Or it shows how to do something without explaining WHY I\u2019m doing it.\n\nI tried messing around with UART protocol. I understand how it works at a physical level, but I can\u2019t get a single peripheral working in practice. I feel like I\u2019m skipping far too many fundamental steps. ",
        "num_comments": 11,
        "comments": [
            "Arduino shields.\n\nMake the connection between the connector pins on an STM32 Nucleo and the wide variety of Arduino shields from Adafruit, Sparkfun, etc. Do you want to interface a motor control, an LCD display, etc? Have a blast, I sure did!",
            "Absolute legend. I started reading the 1st edition a few years ago before the CubeIDE was released. Would have been completely lost without this book.",
            "I attempted a project (my previous post in this sub if youre interested), but I ran into so many roadblocks that Im backtracking a bit to teach myself the fundamentals. It was just a keypad, UART LCD, and some extra logic to make a number base converter calculator. Im going to find something a bit simpler.",
            "Yes, do things as simple as possible. Run a terminal software on your computer and make the stm32 send uart characters. Once you have that working, do it the other way, send data from the terminal software and make the be stm32 receive the data and blink the led if you receive some data. \n\nAlso, if you can, buy a cheap logic analyzer ($10 from ebay) that works with pulseview software. This will immensely help you see the actual uart data. Plus, pulseview have lots of protocol decoder that will help you once you experiment with other protocols like i2c, spi, can",
            "When I was in school, once I learned about using GPIO to blink an LED, I learned about polling and interrupts. I learned about how to constantly poll the processor checking to see if a button was pressed and turning on an LED based on that. Afterwards, learning about interrupts and writing my first ISR and comparing the pros and cons of both polling and interrupts. Also, working with buttons gets you some exposure into bouncing and how you need to write some code that helps alleviate bouncing through debouncing. Personally, I think that would be a next good step. Its nothing crazy but at the same time, its something new as well. \n\nThe STM32 Nucleo has a button and some LEDs as well so you could try creating a program that alternates between different LEDs on the board when a button is pressed\n\n\nEdit: You could jump into communication protocols as well. If you do, I would recommend starting with something a little more simple than UART such as SPI.",
            "You can try to utilize several peripherals to train.\n\nADC to measure sensors.\n\nSPI and I2C to talk to sensors with some kind of protocol (check their datasheet, they often have a command set and sometimes even internal registers which you can use)\n\nTimers to pace your system (for example: read a sensor at 10Hz). Or timers to measure a time delay, a PWM duty cycle, or output a PWM to some actuator.\n\nDAC to set an analog voltage (if your STM32 has this)\n\nUART to have a classic serial comms to interface with PC.\n\nThere are generally 2 ways to program STM32: via HAL or bare metal.\n\nFor HAL, you could use STM32CubeMX code generator to set up the peripheral, and then find the relevant HAL functions. If you don't wnat to use CubeMX, You could also try to find the peripheral Handle typedef it self, instantiate it, and fill the relevant initialization values. A tutorial can help a great deal with this. Imagine that most of this is boilerplate code though, it's just setting things up the way you need a peripheral to work, but not really using it yet. So this would be step 2: figure out what the peripheral should do, and how the HAL exposes this to you. Typically you can choose between several methods to work with a peripheral, for example blocking calls, interrupt callbacks or even DMA.\n\nFor baremetal, it's a lot more involved. You'll need to open the reference manual to find the control registers, prefill all values, then turn peripheral on, and then make things move via data registers and status registers. As I said its more involved and not a great place to start.\n\nIn both cases, it's always good to check if the relevant clock enable bits in the RCC peripheral are set. Those kind of mistakes can make you pull your hair out when things should work but they don't.",
            "Have you tried interfacing your MCU to a terminal? If not, try that. Write a CLI parser/engine with a few commands like: \n- set led on\n- set led on for duration \n- set led off \n- blink led\n- read hardware ID\n- read hardware version\n- read software version",
            "Caveat to point C, I would think its better to write your own RTOS (at least a simple round robin or something) before using FreeRTOS. \n\nTo be fair, Im not a big fan of FreeRTOS in general, so I might be biased.\n\nAlso, for G, second this hard. If you can do it with DMA, try doing it using DMA",
            "Some ideas:\n\nA) RCC abuse - mess with your clock settings and see when it stops being stable and thermally problematic.\n\nB) bit bang spi or I2C ( even if you have the peripherals it's a good exercise to understand the protocols)\n\nC) Try freeRTOS, see what need os it solving and get a feel for when it's more hassle than not.\n\nD) talk to an SD card and implement a filesystem, it's surprisingly easy to talk to SD cards. ( No spoiler)\n\nE) Burn a few chips. See what happens when you fry the hardware. Specifically IO ports. You'll get to know in greater detail the flow and structure of IO port and know what to expect when you do it for real. Sink some current into it and see how long it takes.\n\nF) If you're using an MCU with DSP instructions try to dig deeper. See what your compiler does for you and what it does not what you try some SIMD operations.\n\nG) Become friends with DMA, he's your friend, when he's not trying to kill you. Seriously, try and make some data trains and chain DMA together, it's a useful tool.",
            "This book really helped me:  \n[https://leanpub.com/mastering-stm32-2nd](https://leanpub.com/mastering-stm32-2nd)"
        ]
    },
    "Why is the junior embedded job market dead": {
        "title": "Why is the junior embedded job market dead",
        "score": 109,
        "url": "https://www.reddit.com/r/embedded/comments/1dqkqbr/why_is_the_junior_embedded_job_market_dead/",
        "content": "Just trying to understand reasons behind it. Is the profession headed towards a steady decline or is something else causing this.",
        "num_comments": 139,
        "comments": [
            "In Italy the job market for embedded firmware developers is still alive.",
            "I think a lot of it just has to do with many western economies pumping the brakes to get a handle on inflation. But to be real I remember reading on Reddit about how impossible it was to get a job straight out of college back when I was a junior too and I didn't have any trouble, so take whatever you read on here with a grain of salt.",
            "The job market back in 2008 sucked too for several years sadly. In my experience companies dont want to train Junior devs anymore they want people to hit the ground running. Which sucks because its pulling the ladder up. \n\nBut most of us would like to work with more Junior people (to help us fight against the dinosaurs lol) but corporate hiring dictates a lot of that. Even intern positions seem hit or miss the last 5 years.",
            "Embedded devs tend to become highly specialized and could monopolize the development of a whole product, as a form of job security. With that mindset, companies end up hiring less embedded (or firmware) engineers",
            "I saw it differently from you guys. I figured embedded was one of the first specializations you could get after 3-5 years in a related engineering job. I thought these jobs were for mid to senior level engineers and then something like RF or Semiconductors was pretty much exclusive to phds. RF and Semiconductors focused jobs don't usually have Junior roles do they?",
            "Because the senior devs are looking for and taking the junior positions.",
            "Its the market. There are more engineers with 5+ years of experience than there are jobs. Probably going to be a year or two before it comes back.",
            "I don't know how  businesses plan to progress with out entry level positions. Do they plan on pulling a boeing and failing when the current generation retires?",
            "No one wants to train juniors, unfortunately. \n\nIt takes at least a year before junior becomes useful in a project, and now companies are not willing to put time and effort into it. And even if junior becomes useful within a year and after that they immediately leave, it only effects the company.",
            "I know some companies that use non-software engineers to develop an algorithm in their field of expertise (aerospace, chemical, etc.) in something like Matlab, which has compilers that can get the code to run on an embedded system but it's incredibly inefficient. Instead of letting embedded engineers optimize the algorithm, the company just gets faster hardware or more memory to compensate. \n\nThey'd rather pay more for hardware that's overkill because buying something COTS and incorporating it into their product is more easily understood than having to manage software engineers and do real engineering."
        ]
    },
    "Can I use MCP2515 instead of SN65HVD230?": {
        "title": "Can I use MCP2515 instead of SN65HVD230?",
        "score": 1,
        "url": "https://www.reddit.com/r/embedded/comments/1drdlv2/can_i_use_mcp2515_instead_of_sn65hvd230/",
        "content": "I am starting a course that uses SN65HVD230 can receiver, and I have MCP2515 module. Is mcp can be used instead of SN65HVD230 or do I have to buy SN65HVD230 too? Thank you very much.",
        "num_comments": 0,
        "comments": []
    },
    "TIMXCLK F1 Series": {
        "title": "TIMXCLK F1 Series",
        "score": 4,
        "url": "https://i.redd.it/3ztp0mq3zf9d1.jpeg",
        "content": "I\u2019m trying to figure out this clock tree for TIM7. So let\u2019s say SYSCLK ends up being 72MHz and the AHB prescaler is 1 and then I set my APB1 prescaler to 2 to follow the 36MHz frequency limit on the APB1 bus then I see that it splits to the AND gate for PCLK1 and then there is a path where it goes to pertain to TIM 2, 3, 4  and it says if APB1 prescaler is 1 then x1 else x2 and it leads to TIMXCLK. A couple confusions I have up to the point:\n- I thought that all peripherals of a bus get their clocks derived from the bus frequency, so I\u2019m confused why TIM 2, 3, 4 split to TIMXCLK when they\u2019re part of APB1 bus\n\n- the tree only lists this for TIM2, 3, 4 but TIM2-7 is on the APB1 bus for my MCU aswell, does this mean  this only pertains to specifically 2,3,4? Or is it just shortened\n\n- if they are different (PCLK and TIMXCLK) wouldn\u2019t my TIMXCLK become 72MHz since the prescaler is not 1 so 36MHz is doubled, is this allowed since it\u2019s part of the APB1 bus and the max is 36MHz\n\nI\u2019m confused, any help would be greatly appreciated, thank you!!!",
        "num_comments": 1,
        "comments": [
            "I am guessing that the timers can run on 72MHZ input clock, you are right about the multiplication of 2 from the schematic.\n\nWhat does the reference manual say? How about the datasheet?"
        ]
    },
    "Question: Using Microchip KSZ8863RLL with STM32f207": {
        "title": "Question: Using Microchip KSZ8863RLL with STM32f207",
        "score": 0,
        "url": "https://www.reddit.com/r/embedded/comments/1dr8wx9/question_using_microchip_ksz8863rll_with_stm32f207/",
        "content": "Hello everyone, \n\nI'm developing a device for an industrial environment. But I'm completely new to networking stuff. \n\nI'm planning to use a STM32 and KSZ8863RLL to achieve TCP/IP connection and daisy chain to another device. \n\n1. Does anyone see any problems or limitations with this?\n\n2. The PHY datasheet says there are 5 different modes regarding the clock. Which one to choose and why?\n\nhttps://preview.redd.it/46luliktuh9d1.png?width=848&format=png&auto=webp&s=dfdb9d544db50b0a2dafbaf0527044949e0d92e3\n\nThank you for every contribution, I really appreciate it!",
        "num_comments": 2,
        "comments": [
            "I used the same switch with an H7 recently. \n\nI don't know if the F2 has the same limitation, but make sure you can access all the registers over the MDC interface. You can't with the H7 and I had to bug it into an i2c port to fully configure it. I had used mode 5 (Already had a 25MHz clock available, and prefered internal routing to REF-CLKI3), and couldn't access register 198 otherwise.",
            "That''s indeed a very useful hint, thanks a lot!"
        ]
    }
}
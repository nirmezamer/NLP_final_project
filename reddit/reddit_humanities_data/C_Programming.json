{
    "Latest working draft N3220": {
        "title": "Latest working draft N3220",
        "score": 81,
        "url": "https://www.reddit.com/r/C_Programming/comments/1ay92d4/latest_working_draft_n3220/",
        "content": "https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3220.pdf\n\nUpdate y'all's bookmarks if you're still referring to N3096!\n\nC23 is done, and there are no more public drafts: it will only be available for purchase. **However**, although this is _teeeeechnically_ therefore a draft of whatever the next Standard C2Y ends up being, this \"draft\" contains no changes from C23 except to remove the 2023 branding and add a bullet at the beginning about all the C2Y content that ... doesn't exist yet.\n\nSince over 500 edits (some small, many large, some quite sweeping) were applied to C23 after the final draft N3096 was released, this is in practice as close as you will get to a free edition of C23.\n\nSo this one is the number for the community to remember, and the de-facto successor to old beloved N1570.\n\nHappy coding! \ud83d\udc9c",
        "num_comments": 50,
        "comments": [
            "And please join in a _standing fucking ovation_ for the heroic work of the project editor JHM who wrote the actual document and more than any one other person made the release of C23 happen. \ud83d\udc9c",
            "> C23 is done, and there are no more public drafts: it will only be available for purchase.\n\nWhy is that still a thing in 2024? Do other languages make their specifications only available for purchase? Anyway, just curious.",
            ">although this is *teeeeechnically* therefore a draft of whatever the next Standard C2Y ends up being\n\nIt is still marked as ISO/IEC 9899:2024, so isn't it technically a C23 draft? I'm actually curious about clarification on this because I know the submission for publication was scheduled after the January meeting, so it seems like this might actually be the final working draft pre-submission.\n\nMight just be a typographical mistake of course, I just remember the C23 working drafts started as ISO/IEC 9899:202x so I'd expect C2y to be 202y.\n\nEdit: Finally got a minute to scrounge around and found Meneide's Editor's Report in the form of [N3221](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3221.htm) which includes this paragraph:\n\n>Specifically for the PDF Draft n3220, the only C2Y specific change that has approval is an editorial one to fix a footnote in Annex K to state \"potentially reserved\" rather than just \"reserved\". There are no other changes between the n3220 and n3219.\n\nSo it *is* the C2y working draft, with the only difference from the submission being the single footnote change. This seems like it might be a neat little trick to get around the ISO transparency change that's also noted in the report (they're password locking the actual final draft this time around, so only ISO/IEC members would have access).",
            ">C23 is done, and there are no more public drafts: it will only be available for purchase.\n\nNot necessarily; the [editor's report](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3221.htm) says this:\n\n>ISO/IEC SC22 JTC1 has mandated drafts during the \"DIS\" stage of drafting and balloting for ISO/IEC 9899:2023 must be viewable only by those in the ISO/IEC Global Directory. Therefore, the document n3219 \u2014 the Preliminary DIS Ballot Draft \u2014 will be in a password-protected zip file.\n\n[N3219](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3219.pdf) (currently password-protected) is also referred to as \"the Preliminary C23 DIS Ballot Draft before a final version will be sent to ISO for publication\", so it seems likely that this may be publicly available soon (free version that is).\n\nP.S.: Albeit minor ones, a couple of missing elements in N3220 are index entries for both '**size\\_t**' and '**size\\_t type**' (they probably got overlooked in the C23 crunch, but there are similar entries for other related types such as **ptrdiff\\_t** and **rsize\\_t**).",
            "So guy, what do we get in C26? /j",
            "Great news!  \nI'm just curious: Why do you call it the de-factor successor of N1570 (C99) and not N2176 (C17)?",
            "Now this, while I am still gabbling with the Annex K of C11, not supported anywhere for over a decade.",
            "I think Cobol, Ada, Fortran, Pascal, C, C++, Lisp, Ruby, and Prolog all have ISO standards, which are all available for purchase.\n\nISO claims the money is to fund the development of the standards, but afaik the committees are usually unpaid volunteers and it seems like most people just agree it's funding bureaucracy.\n\nECMA, meanwhile, works on EcmaScript and C\\# standardization without charging, while the ISO literally sells the ECMA standards as ISO standards. It's kind of absurd.",
            "ISO being the authority here is the problem... they're so greedy! And no, you won't find \"free released standards\", since literally every single cyber crime force would shred anybody who dared publish such a thing to pieces... and yes, ***they know***, think of how gangs and cartels operate, they never stop searching for their enemy until they have his head...",
            "It's pretty common to have \"official\" standards which cost money, while unofficial descriptions of the standards are free.  Many standards organizations require some money to operate, and selling \"official\" copies of the Standard is how they stay in business.\n\nIf a company wants to sell parts for use in aircraft, it would not be sufficient for them to say \"our parts conform to some description of this standard that we found somewhere on the Internet\".  They would need to instead purchase an official copy of the specification, and certify that their part satisfied all of the requirements thereof.  In many cases, official copies will include precise validation procedures, while unofficial descriptions will say how to meet requirements without going into detail about how conformance would be verified.\n\nAn aspect of the C Standard which is a bit different from many other standards, however, is that its definitions of \"conformance\" are rather murky and effectively useless.  Almost any blob of bits could be transformed into a \"Conforming C Program\" by contriving a \"Conforming C Implementation\" that would extend the language to \"accept\" it, and there are almost no non-contrived circumstances where anything an otherwise-conforming C implementation might do with any particular source file, after producing at least one diagnostic (even an unconditional \"Warning--water is wet.\") would render it non-conforming.  Almost anything having to do with an implementation actually being *usable* for any purpose is a \"quality of implementation\" matter over which the Standard waives jurisdiction."
        ]
    },
    "2 Months of Game Dev in C": {
        "title": "2 Months of Game Dev in C",
        "score": 22,
        "url": "https://youtu.be/4mGYihePrD0",
        "content": "",
        "num_comments": 5,
        "comments": [
            "Nice! Good to see more people trying game dev in C :)\n\nPeople knock it for being \"too hard\", but tbh starting a game project in C  also for a game jam made me enjoy programming again after years of burnout.\n\nYou've got a great start, and the game looks fun. Keep it up!",
            "You're back! I'm back!\n\n- More stable audio! (But very bitrate-y, harsh compression.)\n- huh.exe!\n- Nice to see you focus on giving credit to your inspiration\n- Still `i32`'ing your `main`, I see. Although it practically doesn't matter, technically I believe your `main` function should explicitly return \"`int`\", and not a fixed sized integer, and the same regarding the `argc` parameter. Everything else in your own code is fair game. Pedantic, but I get the feeling that you don't know why, and I think you should know (and THEN you can say fuck it and use your *mostly* compatible typedefs).\n- Man, just give those `*stars` to the identifier already xD (If it's still unclear what I mean here, although controversial the consensus is to put the pointer indicator (`*`) immediately preceeding the identifier. There are reasons for this, but if you strongly prefer to infix the `*` in your own projects, then I think it's fine.)\n- Is it intended that the particle effects are overlapped by the level geometry?\n- Something about the particles that annoyed me is that the initial ramp-up follows the character sprite, and then sticks to the position it explodes from. Several ways to fix this, but as it is, I personally feel it lacks pop.\n- The video editing is a little confusing. Lots of OBS and irrelevant stuff shown on screen... I liked the transitions, tho! (but the title cards were a little fast for me to read)\n- Was the camera panning issues caused by the spatial hashmap you mentioned in the previous video?\n- Do you need to link `opengl32` when you link `SDL2`?\n- Didn't get to actually *see* any enemies in the section about enemies :(\n- I see some `strncat`'s... for example in `gfx_draw_lvl`. Suspicious. What are these for? Also `strlen`. Code smell.\n- Wait, what? What in God's name are you doing with the arrow operator xD \"`lvl -> x_pos_str`\"? :O I mean, I never even thought of that, and it looks cool and clean, but man is it unconventional. When you do, for example \"`&lvl -> tilemap`\" this code style is very misleading.\n- [@7:31](https://youtu.be/4mGYihePrD0?si=c0LH0seLqmsvCJXU&t=451) u/stianhoiland mentioned! Yep, that seems to be what I had in mind. Very lightweight as compared to a hashmap. (You don't have to explicitly set the first enum member to 0, btw.)\n- \"Tiles Around\" - I love the way you showed this in the video. Very cool. Good solution and very effective illustration of the solution.\n- Outro: Reflecting on how much longer things take to complete. My guess is that it would have taken you quite a bit longer than initially assumed, no matter what.\n- I found your code on https://github.com/1devm0/aer0blaster.1-public (which I looked for a link to but didn't find in the video description). I noticed that you're doing some sketchy stuff with the sizes of your arrays, like `particles` and `attk_gun`. Ex. you `malloc` `attk_gun` at [line 85](https://github.com/1devm0/aer0blaster.1-public/blob/c44ded6452b21de8a44b7569fb6c54133c57997f/src/main.c#L85) with a hardcoded size of `10`, and then you `memset` it at [line 266](https://github.com/1devm0/aer0blaster.1-public/blob/c44ded6452b21de8a44b7569fb6c54133c57997f/src/main.c#L266) & 277 with a hardcoded size of `10`. There are probably other places in your code where you handle these arrays like that, and if a single usage falls out of sync with the rest of your size-handling code, you've got some nasty bugs. The solution is to use either a constant (often `#define PARTICLES_MAX 120`), or a variable (often `i32 particles_count`, maybe in a struct together with `gfx_particle_t *particles`).\n- Still doing `u08` I see! My point here earlier is that I've never seen \"`u08`\", but have often seen \"`u8`\"\n\nAll in all, thanks for sharing your progress and good luck with the project! :)",
            "Thank you!",
            "Oh, and another little trick when it comes to handling array sizes:\n\nAlthough it seems, conceptually, that the thing whose size you are interested in specifiying is the type, like so:\n\n    attk_gun = calloc(10, sizeof(gfx_particle_t));\n\n... what you really want in this case is actually *whatever the type of `attk_gun` is*, or rather, the type pointed to by `attk_gun`:\n\n    attk_gun = calloc(10, sizeof *attk_gun);\n\nYou can also write this (with subtly different semantics, I believe):\n\n    attk_gun = calloc(10, sizeof attk_gun[0]);\n\nThis is safer and will automatically suit any changes you make to the (dereferenced) type of `attk_gun`.\n\nNote: `sizeof` requires the use of parenthesis when directly specifying a type name, but not when specifying an expression. I prefer to not use the parenthesis (just like I don't use parenthesis for `return(0)`).",
            "* Yeah, I stuck to one device for recording this time so the audio was a lot more stable but next time I'll try to record in a completely silent room because the noise reduction in DaVinci really had an impact on the quality. \n* Right, the \\`i32\\` main thing, how big of a difference would it really make? In my mind, the only thing that pops up is how on a 64-bit system, the default integer wouldn't be i32, it'd be i64 (correct me if I'm wrong) but even then the value I'm going to be returning isn't going to be close to the limits of any of these types. Plus, the only reason I have the argv and argc is because of how SDL\\_main defines the main function to have these parameters (though I just tried compiling by redefining main in the SDL file and it works fine, not sure if it'll work on other platforms though)\n* \ud83d\ude2d i like ptr\\_t \\* p;\n* What do you mean particle effects are overlapped by the level geometry? The geometry is drawn before the particles so the level geometry is supposed to be overlapped by the particles.\n* Hm, I don't get what you mean. Are you talking about the camera shifting and then the sparks flying out once the bullet hits something or what?\n* I tried to do something new with the video-editing this time but I tried my best to make sure that whatever was on the screen was relevant to what I was talking about like the player falling through the tiles or just showing the relevant code on screen. \n* The camera panning issue was related to me only getting tiles on the screen because when the bullet would move too far, the player would not remain on screen and the tiles the player was standing on would also not be on the screen, and so the player would just fall through. \n* Nope, thanks for telling me this as I copy-paste the makefiles I use in my other projects and I forgot to remove the opengl32 this time. \n* No Enemies in the enemies section, my bad.\n* Basically, the strncat and strlen is meant to be used for doing a look-up in the spatial hashmap. I've realized that this is really not ideal and has caused quite a bit of performance issues on an older machine I have so I will be rewriting my hash table API and most likely the cutils library that I am using. The strncat and stuff are used because the hash table only supports (string, data\\_type) key-value pairs rather than any type of key. I just wanted to get this devlog out so that I can work on this major change.\n* \ud83d\ude2d\ud83d\ude2d\n* I'll be revisiting the animation system again to just make sure that I haven't screwed up anything. \n* Outro Comments: Fair\n* Yeah, I should definitely use some defined constant (or the calloc thing you've mentioned in your second comment)\n\n  \nThank you very much for taking the time last time as well as this time to watch my video and give me meaningful feedback. I appreciate it. I have one last question, which video was better in your opinion? The first one or the second one?"
        ]
    },
    "What can we assume about a modern C environment?": {
        "title": "What can we assume about a modern C environment?",
        "score": 49,
        "url": "https://www.reddit.com/r/C_Programming/comments/1dqne0b/what_can_we_assume_about_a_modern_c_environment/",
        "content": "So, as we know, the C standard is basically made to be compatible with every system since 1980, and in a completely standard-compliant program, we can't even assume that `char` has 8 bits, or that any `uintN_t` exists, or that letters have consecutive values.\n\nBut... I'm pretty sure all of these things are the case in any modern environment.\n\nSo, here's question: If I'm making an application in C for a PC (or Mac) user in 2024, what can I take for granted about the C environment?",
        "num_comments": 42,
        "comments": [
            "Very interesting question; it calls for a good discussion, and I think the post should be tagged as such (add flair).\n\nTo start with, I'll state the most important assumption for any C programmer using a modern compiler:\n\n***Assume that the compiler will definitely do something unexpected if the code has undefined behavior.***\n\nHere's a small list of some lesser assumptions about most (but not all) modern hosted environments:\n\n* ASCII encoding for characters\n* Plain `char` is signed\n* `CHAR_WIDTH == 8` (required by POSIX)\n* `EOF == -1`\n* Two's complement representation for signed integer types (required in C23)\n* IEEE 754 representation for standard floating types\n* `sizeof (short) == 2`\n* `sizeof (int) == 4`\n* `sizeof (long long) == 8`\n* Least-width types are same as their corresponding exact-width types\n* Fast-width types follow the expected rank hierarchy in order of width\n* `uintptr_t` and `intptr_t` are available with a trivial mapping from pointer to integer type\n* No padding bits in arithmetic types (excluding `_Bool` and C23 `_BitInt`)\n* No padding bytes between consecutive `struct` members of the same type\n* No unnecessary padding between `struct` members, just the minimum padding for alignment\n* Function pointers can be freely converted to and from `void *` (required by POSIX)\n* All pointer types have the same representation\n* Dereferencing *pointer-to-array* is a no-op\n* `calloc` implementation will detect a multiplication overflow, instead of silent wraparound\n* Library functions additionally provided as macros do not evaluate any argument more than once.",
            "* sizeof(char)==1 // always true anyway, but you see sizeof(char) in quite a lot of code.\n* free(NULL), though pointless, is OK (IOW, modern systems are more standards compliant)\n* You don't really need to worry too much (any more) about the maximum significant length of identifiers having external linkage",
            "> If I'm making an application in C for a PC (or Mac) user in 2024, what can I take for granted about the C environment?\n\nDamned little.\n\nIf you have to account for exact type sizes or representations, get that information from `<fenv.h>`, `<float.h>`, `<inttypes.h>`, `<limits.h>`, etc.; don't make assumptions on what a \"modern\" system *should* support.  Even \"modern\" systems have some unwelcome variety where you wouldn't expect it.   \n\nThe only things you can assume are what the [language standard](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3220.pdf) guarantees, which are *minimums* for the most part.",
            "Outside of embedded systems\u2026\n\n* Sizes: char is 8 bits, short is 16, int is 32, long long is 64. A long is either 32 or 64. That said, if you need a specific size, it\u2019s always clearer to use `intN_t` types.\n* Alignment: Natural alignment for integers and pointers.\n* Pointers: all pointers have the same representation, and you can freely convert pointers from one type to another (but you can\u2019t then *dereference* the wrong type).\n* Character set is UTF-8, or can be made to be UTF-8 (Windows).\n* Code, strings, and const globals are stored in read-only memory, except for globals containing pointers in PIC environments.\n* Signed right shift extends the sign bit. Numbers are twos complement.\n* Floats are IEEE 754.\n* Integer division truncates towards zero.\n* Identifiers can be super long. Don\u2019t worry about the limits.\n* Strings can be super long. Don\u2019t worry about the limits.",
            "Why do you need assume something?\n\nYou can ,if necessary, make assumptions using for a particular code using static_assert or # if. \n\n```c\n#if CHAR_BIT < 8\n#error we need CHAR_BIT 8\n#endif \n```\n\netc...",
            "Don't undershoot. If you're writing for a POSIX environment, then *assume* a POSIX environment! Don't just restrict yourself to \"standard C.\" Go ahead and write down \"this application assumes POSIX level XXX\" and work from there.\n\nYou'll get more functions, more sensible behavior, and you won't feel guilty about leaving memory behind for the system to clean up ;-)",
            "C sometimes tries to be portable across every architecture of the past *fifty* years, although C23 is starting to walk that back a little, and now at least it assumes two\u2019s-complement math. You can\u2019t assume that `char` is 8 bits because what you actually *can* assume that `char` is the smallest object that can be addressed, and there are machines where that\u2019s a 32-bit word.\n\nIn practice, several other assumptions are so widely supported that you can often get away with not supporting the few exceptions. This is a Chesterton\u2019s-fence scenario: there was a reason for it originally, and you want to remove the fence only if you know that it is no longer needed.  You also may want to make the assumption explicit, with a `static_assert` or `#if/#error` block.\n\nA partial list of what jumped to mind:\n\n* The source and execution character sets are ASCII-compaible. (IBM\u2019s zOS compiler needs the `-qascii` option, or it still defaults to EBCDIC for backwards compatibility.)\n* The compiler can read UTF-8 source files with a byte order mark. Without the BOM or a command-line option, modern versions of MSVC will try to auto-detect the character set, MSVC 2008 had no way but the BOM to undersatand UTF-8 source files, and clang only accepts UTF-8 with or without a BOM, so UTF-8 with a BOM is the only format every mainstream compiler understands without any special options.\n* Floating-point is IEEE 754, possibly with extended types. (I\u2019m told Hi-Tech C 7.80 for MS-DOS had a different software floating-point format.)\n* All object pointers have the same width and format. (Some mainframes from the \u201970s had separate word and character pointers, where the character pointers addressed an individual byte within a word and had a different format.)\n* A `char` is exactly 8 bits wide, and you can use an `unsigned char*` to iterate over octets when doing I/O.\n* Exact-width 8-bit, 16-bit, 32-bit and 64-bit types exist. (The precursor to C was originally written for an 18-bit computer, the DEC PDP-8.)\n* The memory space is flat, not segmented. You can compare any two pointers of the same type. If you have 32-bit pointers, you aren\u2019t limited to making each individual object less than 65,536 bytes in size. All pointers of the same type can be compared to each other. (The 16-bit modes of the x86 broke these assumptions.)\n* The memory space is either 32 bits or 64 bits wide. (Not because hardware with 16-bit machine addresses doesn\u2019t still exist, but because your program could not possibly run on them.)\n* A function pointer may be cast to a `void*`. POSIX requires this (because of the return type of `dlsym()`), but there are some systems where function pointers are larger than object pointers (such as DOS with the Medium memory model).\n* The optional `intptr_t` and `uintptr_t` types exist, and can hold any type of pointer.\n* Integral types don\u2019t have trap representations. (The primary exceptions are machines with no way to detect a carry in hardware, which may need to keep the sign bits clear to detect a carry, when doing 32-bit or 64-bit math.)\n* **Questionably:** The object representation of a null pointer is all-bits-zero. There are [some obsolete historical exceptions, many of which changed their representation of `NULL` to binary 0,](https://c-faq.com/null/machexamp.html) but this is more likely to bite you on an implementation with fat pointers.",
            "Assuming that bytes consist of 8 bits is probably pretty safe on most platforms.",
            "A long, long time ago, you could use autoconf to help with portability. \n\nYou could also add checks in main() as a first thing if you know your code is going to depend on certain things, for example the computer being little endian, or the size of an int being 4 bytes or a char being 8 bits. \n\nSo for instance in main(), \nif (sizeof(int) != 4)\n{\n    fprintf(stderr, \u201cexpected 4 byte integers\u201d);\n    exit(EXIT_FAILURE);\n}\n\nNot fool proof but Best to fail fast if certain underlying assumptions cannot be met.",
            "C compilers will be *configurable* to process overflow in quiet-wraparound two's-complement fashion, though in default configuration they may instead process it in ways that may arbitrarily corrupt memory even if the overflow should seemingly have no possible effect on program behavior (e.g. gcc will sometimes process\n\n    unsigned mul_mod_65536(unsigned short x, unsigned short y)\n    {\n      return (x*y) & 0xFFFFu;\n    }\n\nin a manner that will arbitrarily corrupt memory if `x` exceeds `INT_MAX/y` unless optimizations are disabled or the `-fwrapv` compilation option is enabled).\n\nC compilers will be *configurable* to uphold the Common Initial Sequence guarantees, at least within contexts where a pointer to one structure type is converted to another, or where a pointer is only accessed using a single structure type, though neither clang nor gcc will do so unless optimizations are disabled or the `-fno-strict-aliasing` option is set.\n\nC compilers will be *configurable* to allow a pointer to any integer type to access storage which is associated with any other integer type of the same size, without having to know or care about which particular integer type the storage is associated with, at least within contexts where a pointer to one structure type is converted to another, or where a pointer is only accessed using a single structure type, though neither clang nor gcc will do so unless optimizations are disabled or the `-fno-strict-aliasing` option is set."
        ]
    },
    "Was in bed thinking about unions (as you do) and thought of something I had to try. Booted my PC up to a TTY and typed this out and surprisingly it compiles and runs: sizeof for an array size": {
        "title": "Was in bed thinking about unions (as you do) and thought of something I had to try. Booted my PC up to a TTY and typed this out and surprisingly it compiles and runs: sizeof for an array size",
        "score": 4,
        "url": "https://www.reddit.com/r/C_Programming/comments/1dr54mb/was_in_bed_thinking_about_unions_as_you_do_and/",
        "content": "maybe this was something everyone knew about, but I couldn't find any info searching about it online (combinations of keywords 'sizeof' and 'array' just brings up beginner posts about how to use malloc....), but I was thinking about how unions can be used for type punning (specifically about how this is disallowed by the standard, but it doesn't really matter because in practice everyone uses unions for this exact reason and every compiler will make it work), and the following construct popped into my head, so I wanted to try it to see if it compiled and ran. I thought it should, because `sizeof` is compile-time constant, but I was fully expecting to be hit with an error about an array size being invalid.\n\n`code:`\n    \n    #include <stdio.h>\n    union foo {\n            int i;\n            char bytes[sizeof(int)];\n    };\n    \n    int main(void)\n    {\n            union foo foo = { .i = -1 };\n            for (int i = 0; i < sizeof(int); i++) {\n                    printf(\"%hhB'\", foo.bytes[i]);\n            }\n            return 0;\n    }\n\n`output:` (as expected)\n    \n    11111111'11111111'11111111'11111111'\n    \n(and setting `.i = 10` outputs `1010'0'0'0'`, which I figured has to do with endianness or the order that the compiler accesses the elements of `.bytes`, which I figure is what makes this kind of union type-punning not part of the standard)\n\ntaking advantage of the new C23 binary print specifiers too! (although it would've worked anyways because I'm using GCC and GNU has has them as an extension for a while :p) \\*\n\nlooking at this, I think, aside from the use of unions for type pun the `int` into `char`s, it would be a fully standard compliant way to look at the individual bytes of a variable and it would be fully portable (as much as the rest of the standard ensures programs are portable, I.E., could even compile and run on a computer with 16 bit ints or something crazy).\n\nI figured this was kinda cool so I thought I'd share it :D\n\n\\* UPDATE: Remembered another C23 thing I wanted to try: `typeof`. Unfortunately, I don't think there's a way to reference `i` within a `typeof` (which we could then put inside of the `sizeof`), and we cannot use `union foo` becuase it's an incomplete type. This doesn't really matter, but it would be kinda cool to not have that type hardcoded in. It would feel more flexible that way, but I think in any situation you'd actually be using this type of low level byte manipulation, that is unnecessary",
        "num_comments": 5,
        "comments": [
            ">Was in bed thinking about unions (as you do) and thought of something I had to try.\n\nYou must be a clairvoyant psychic to accurately read other people's thoughts like that.\n\n\"*unions*\" can be used in a \"*procreative*\" way (pun intended), though I'd prefer `(char *)` cast.",
            "```\n#include <stdio.h>\n#include <limits.h>\nunion foo {\n        int i;\n        char bytes[sizeof(int)];\n};\n\nint main(void)\n{\n        union foo foo = { .i = -1 };\n        for (int i = 0; i < INT_MAX; i++) {\n                printf(\"hhB'\\n\", foo.bytes[i]);\n        }\n        return 0;\n}\n```\n\nVery obviously does not print\n```\n11111111'11111111'11111111'11111111' \n```\n\nNot because you're wrong about umions. Because that's now how `INT_MAX` and `printf` work.. \n\nBut also, you obviously didn't run the code as written.",
            "> specifically about how this is disallowed by the standard\n\nUnion type punning is allowed by C standard. C++, not.",
            "sorry, that was a typo, it's late. That was meant to be `sizeof(int)` thanks :'D",
            "I just checked the standard and I think you are correct. I think I misread a section on aliasing o.O"
        ]
    },
    "First C \"project\" | String reversal": {
        "title": "First C \"project\" | String reversal",
        "score": 2,
        "url": "https://www.reddit.com/r/C_Programming/comments/1dr5jid/first_c_project_string_reversal/",
        "content": "As a somewhat beginner (I started C a week ago), I am proud of this and wanted to share it. This code takes a word then prints it out... but reversed. Any tips for more efficient ways I could've done this are welcome\n\n    #include <stdio.h>\n    int main() {\n    \u00a0 \u00a0int num;\n    \u00a0 \u00a0printf(\"enter amount of letters for reversal!!!!: \");\n    \u00a0 \u00a0scanf(\"%d\", &num);\n    \u00a0 \u00a0int num2 = num;\n    \u00a0 \u00a0printf(\"enter string(must have amount of letters entered): \");\n    \u00a0 \u00a0char inp[num+1];\n    \u00a0 \u00a0scanf(\"%s\", &inp); \n    \u00a0 \u00a0char* inp_p = &inp;\n    \u00a0 \u00a0\n    \u00a0 \u00a0for (int i = 0; i<=num; i++) {\n    \u00a0 \u00a0 \u00a0 printf(\"%c\", *(inp_p+num2));\n    \u00a0 \u00a0 \u00a0 num2 = num2-1;\n    \u00a0 \u00a0}\n    \u00a0 \u00a0\n    \u00a0\n    \u00a0 \u00a0\n    return 0;\n    }",
        "num_comments": 9,
        "comments": [
            "Good effort. Here's a few minor bug-fixes and suggestions:\n\n* The loop runs from `0` to `i <= num`, which means `num+1` iterations (including 0). `num2` is initialized to `num`, which means `*(inp_p + num2)` prints the null byte in the first iteration. This is unnecessary, so the loop should `num` times (from `0` to `i < num`), and `num2` should be initialized to `num - 1`.\n* ***Always*** **compile with warnings enabled**. `scanf` should start storing the input from address of the first array element, so the argument should be `&inp[0]` (read as \"address of element at index `0`\"). In C, a shorthand notation is to write just the array name `inp`, which \"*decays*\" to address of the base element; there are few exceptions to this, notably `sizeof` and `&`  (address-of) operators (and a few others).\n* Due to the aforementioned *array decay*, it should be `char *inp_p = inp;` (your code has `&inp`).\n* ***Always*** **check the return value of** [**scanf**](https://port70.net/~nsz/c/c11/n1570.html#7.21.6.4p3), which indicates the number of input items successfully converted and stored. It should be something like: `if (scanf(\"%s\", inp) != 1) return 1;`\n* `char inp[num+1]` is a *variable length array* (VLA) with automatic storage created on the function stack. VLA support is optional since C11, so prefer heap-based programmer-managed allocation with [malloc](https://port70.net/~nsz/c/c11/n1570.html#7.22.3.4) and friends.\n* `putchar(inp_p[num2])` is faster than `printf`, but compilers may already optimize that for you.\n* `return 0;` is optional only for the `main` function since C99 (this is a special rule, it was required in C89/90)\n* Here's the obligatory: [https://sekrit.de/webdocs/c/beginners-guide-away-from-scanf.html](https://sekrit.de/webdocs/c/beginners-guide-away-from-scanf.html)\n\nFor reading a string, `scanf` is overkill, and the `\"%s\"` format specifier is as dangerous as the deprecated ~~g\\*ts~~ function, as `scanf` doesn't know the buffer capacity, so it may write past the array, corrupting adjacent memory with arbitrary (and potentially malicious) user input. You can specify a limit, such as `\"%99s\"` means at most `99` characters of user input, followed by a null byte (which means array size must be *at least* `100`).\n\n*TL;DR*: Avoid `scanf`, `fgets` is your friend: [https://port70.net/\\~nsz/c/c11/n1570.html#7.21.7.2](https://port70.net/~nsz/c/c11/n1570.html#7.21.7.2)",
            "1. Write a function to do the string reversal \n2. Don't you have an off by one error in the loop?\n3. Why not just loop from the end to the front?",
            "It would be a lot nicer to use if you could read in a string and then detect the length of the string. Then calculate the length of the string after. Something like this?\n\n    char myString[256];\n    fgets(myString, sizeof(myString), stdin);",
            "Right now all your code is in one place. Think about breaking it into functions. For example: you can write a function that gets the user input string..another one that reverses the string. These two functions could be totally independent and then the main just calls them in order.\n \n\nThis will make your code modular, easier to debug and work with.\n\nAlso, this is a small program. But comment  your code.",
            "Yeah but your iterator is incrementing. You wouldn't have to juggle the numbers so much if you just started at the end and decremented to 0. I'm on phone, but something like\n\nfor (i=string_length; i >= 0; --i)...",
            "Not gonna lie im tired right now so some things you said aren\u2019t clicking for me, but still thanks for introducing me to some things I didn\u2019t know like scanf having the potential to mess up memory, not having to use printf, etc.",
            "1) Okay, i was thinking about that when I finished.\n\n\n2) nope it works perfectly, no errors.\n\n\n3) That\u2019s what it does, wym? Im using a for loop to loop it from the last letter (end) to the first letter (front)",
            "Ah okay I see what you\u2019re saying. Btw \u2014i decrements just like i\u2014 would right? I\u2019ve never seen the \u201c- -\u201c come before",
            "Personally, I would prefer the way you're doing it. There are some difficult to spot errors that come up when you try to do backwards iteration. Particularly when you use unsigned numbers. So I just keep things consistent and always iterate up. I would just use a variable declared inside the loop though. Like this:\n\n    for (int i = 0; i <= num; ++i) {\n        int index = num - i;\n        ..."
        ]
    }
}
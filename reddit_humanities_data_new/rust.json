{
    "Hey Rustaceans! Got a question? Ask here (25/2024)!": {
        "title": "Hey Rustaceans! Got a question? Ask here (25/2024)!",
        "score": 8,
        "url": "https://www.reddit.com/r/rust/comments/1dhu8le/hey_rustaceans_got_a_question_ask_here_252024/",
        "content": "Mystified about strings? Borrow checker have you in a headlock? Seek help here! There are no stupid questions, only docs that haven't been written yet. Please note that if you include code examples to e.g. show a compiler error or surprising result, linking a [playground](https://play.rust-lang.org/) with the code will improve your chances of getting help quickly.\n\nIf you have a [StackOverflow](http://stackoverflow.com/) account, consider asking it there instead! StackOverflow shows up much higher in search results, so having your question there also helps future Rust users (be sure to give it [the \"Rust\" tag](http://stackoverflow.com/questions/tagged/rust) for maximum visibility). Note that this site is very interested in question quality. I've been asked to read a RFC I authored once. If you want your code reviewed or review other's code, there's a [codereview stackexchange](https://codereview.stackexchange.com/questions/tagged/rust), too. If you need to test your code, maybe [the Rust playground](https://play.rust-lang.org) is for you.\n\nHere are some other venues where help may be found:\n\n[/r/learnrust](https://www.reddit.com/r/learnrust) is a subreddit to share your questions and epiphanies learning Rust programming.\n\nThe official Rust user forums: [https://users.rust-lang.org/](https://users.rust-lang.org/).\n\nThe official Rust Programming Language Discord: [https://discord.gg/rust-lang](https://discord.gg/rust-lang)\n\nThe unofficial Rust community Discord: [https://bit.ly/rust-community](https://bit.ly/rust-community)\n\nAlso check out [last week's thread](https://reddit.com/r/rust/comments/1dcge95/hey_rustaceans_got_an_easy_question_ask_here/) with many good questions and answers. And if you believe your question to be either very complex or worthy of larger dissemination, feel free to create a text post.\n\nAlso if you want to be mentored by experienced Rustaceans, tell us the area of expertise that you seek. Finally, if you are looking for Rust jobs, the most recent thread is [here](https://www.reddit.com/r/rust/comments/1cixuzr/official_rrust_whos_hiring_thread_for_jobseekers/).",
        "num_comments": 54,
        "comments": [
            "Hello, I have questions about structuring my errors on large library projects. I'm using `thiserror` while I understand the concept, it feels like I'm using it incorrectly so I'm looking for some untold rules, some good resources or repository examples.\n\n- I have multiple dependencies which have their own errors, and started to just add them with some `#[error(transparent)]`and `#[from(LibError)]` but it starts to make my error enum too big. I suppose it is not a good pratice to just wrap the lib error everytime, so is there any rules that anyone would want make a new error variant instead of a wrapper ?\n- Is it good pratice to share an error variant in two contexts that are differents ? Let's say I have a `DecodeError`, is it wrong to use it at the same time while decoding UDP packets, and while decoding a zip file ?\n- Is it better to have a large error for the whole project, of some kind of module separation that would follow file structure ?\n- While `?` is a wonderful shorthand to handle errors, I feel like I need to do a lot of `map_err` or `ok_or`, is this normal ?\n- I know the answer of this one would be \"it depends\", but how much verbose does an error needs to be ? I feel like I try to include to much informations in my error, while it maybe is the job of the logs.\n\nThanks !",
            "Is there a way to benchmark *private* functions other than using the forever unstable, mostly deprecated, and pretty high friction libtest / builtin bench harness?",
            "Hey!  Does anyone know a good minimal http routing crate?\n\nI was looking at [`httprouter`](https://github.com/ibraheemdev/httprouter-rs) which looks perfect, but it seems like it's deprecated and doesn't work with the current version of `hyper`",
            "I'm working on translating a C program to Rust:  \nC version: [https://github.com/Roman-Oliynykov/Kupyna-reference](https://github.com/Roman-Oliynykov/Kupyna-reference)\n\nRust version (by me): [https://github.com/AnarchistHoneybun/kupyna\\_reference](https://github.com/AnarchistHoneybun/kupyna_reference)\n\nthe C code does a lot of pointer arithmetic and manipulation, and one of them has stumped me very bad:\n\n    void AddRoundConstantQ(uint8_t state[NB_1024][ROWS], int columns, int round) {\n        int j;\n        uint64_t* s = (uint64_t*)state;\n        for (j = 0; j < columns; ++j) {\n            s[j] = s[j] + (0x00F0F0F0F0F0F0F3ULL ^ \n                    ((((columns - j - 1) * 0x10ULL) ^ round) << (7 * 8)));\n        }\n    }\n\n  \nConsider my attempt at it: \n\n    fn add_round_constant_q(\n        state: &mut [[u8; ROWS as usize]; NB_1024 as usize],\n        columns: i32,\n        round: i32,\n    ) {\n        let state_u64: &mut [u64] = unsafe {\n            std::slice::from_raw_parts_mut(\n                state.as_mut_ptr() as *mut u64,\n                state.len() / mem::size_of::<u64>(),\n            )\n        };\n        for j in 0..columns {\n            state_u64[j as usize] = state_u64[j as usize]\n                ^ (0x00F0F0F0F0F0F0F3\n                    ^ ((((columns - j - 1) * 0x10) as u64 ^ (round as u64)) << (7 * 8)));\n        }\n    }\n\nI simply can't understand how to do the part where the 8bit data pointer is recast as 64 bit. Any help is appreciated, because this codebase has already driven me half insane",
            "Can I make a program that respects the user's power saving settings? I am using GNOME and I can choose between \"Power Saver\", \"Balanced' and \"Performance\". \n\nI want the indexer to use less threads when \"Power Saver\" is enabled, a good default value if \"Balanced\" and on \"Performance\" I want one thread per core.\n\nI just want the indexer to not spin up the fans if the user wants to restrict their power usage. Maybe even disable it.",
            "I'm writing an asynchronous CLI application that includes results and an interactive options terminal. Is there a good/easy way to ensure progress updates and the interactive component don't collide with each other in the terminal? A very basic description of the app is main -> handler (interactive term here)-> tokio joinset -> tokio task (print result here)-> rayon task.\n\nIt seems like the only way is an event-driven \\`Console\\` component, but I'm unsure how \\`env\\_logger\\` would handle using this. Either way, seems like a bit of work so would appreciate some ideas :)",
            "merciful lunchroom offer office abundant cake hunt wasteful market berserk\n\n *This post was mass deleted and anonymized with [Redact](https://redact.dev)*",
            "Hi all, I am pretty new to Rust, and cannot get my head this problem.\n\nI have a function. The input to the function is a usize integer, used as an index. The function contains an array; the array is a list of words (e.g. \"first\", \"second\", \"third\", etc.). The output of the function is the n-th word in the array as specified by the input index.\n\nHowever, I am unable to understand how to define the data types correctly, and I am getting error messages that I do not know how to resolve.\n\nCurrently, my code is follows:\n\n    fn main() {\n    \tprintln!(\"Printing: {}\", ordinal_adverbs(4));\n    }\n    \n    fn ordinal_adverbs(n: usize) -> &str {\n    \tlet words = [\"first\", \"second\", \"third\", \"fourth\", \"fifth\", \"seventh\", \"eighth\", \"nineth\", \"tenth\", \"eleventh\", \"twelveth\"];\n            words[n]\n    }\n\nHope someone could help. Thanks!",
            "Hello, I'm making an HTTP API; the service is a single POST request endpoint. I'm looking to ensure the endpoint can handle a supremely high throughput as our main web server where the endpoint currently lives is in Python and suffering.\n\nI'm just using native Tokio from the tutorial because I assume it's the lowest-level of an HTTP server. Do other web frameworks in Rust do more optimizations than plain Tokio spawning a new task?\n\n```rust\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error + Send + Sync>> {\n    let addr = SocketAddr::from(([127, 0, 0, 1], 3524));\n    let listener = TcpListener::bind(addr).await?;\n    println!(\"Listening on http://{}\", addr);\n    loop {\n        let (stream, _) = listener.accept().await?;\n        let io = TokioIo::new(stream);\n        tokio::task::spawn(async move {\n            if let Err(err) = http1::Builder::new()\n                .serve_connection(io, service_fn(handle_request))\n                .await\n            {\n                println!(\"Error serving connection: {:?}\", err);\n            }\n        });\n    }\n}\n```",
            "Hello Rustaceans!\n\nI've encountered a scenario in Rust's type system involving mutable and immutable references that I'm trying to understand better. Here\u2019s a concise description of the situation:\n\nI have two struct definitions, X and Y, which are defined as follows:\n\n```rust\nstruct X<'a> {\n    x: &'a i32,\n}\n\nstruct Y<'a> {\n    y: &'a mut i32,\n}\n```\n\nAnd two corresponding functions:\n\n```rust\nfn f2<'a, 'b>(x: &'a X<'b>) -> &'b i32 {\n    x.x\n}\n\nfn g2<'a, 'b>(y: &'a Y<'b>) -> &'b i32 {\n    y.y\n}\n```\n\nThe function `f2` compiles without any issues, but `g2` results in a compilation error, suggesting a lifetime issue. The error suggests adding a constraint `'a: 'b` to ensure that the lifetime `'a` outlives `'b` .\n\nCould someone explain why this error occurs only with mutable references ( `&mut` ) and not with immutable ones ( `&` )? I am particularly interested in a theoretical explanation in line with Rust's specifications on how its type system and borrow checker handle these scenarios.\n\nThanks for your insights!\n\nhttps://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=6cb00436eb1737afc6f81b8465b77a0e",
            "I feel like I'm doing something wrong, or at least sub-optimal.\n\nI'm defining a trait Foo.  \nI want to have a type that I use in various structs and function calls that is \"Foo + Debug\"  \nWhat I have is \n\n`pub trait FooDebug: Foo + Debug {}`  \n  \nand then wherever I implement a type for this I need to say\n\n`#[derive(Debug)]`  \n`struct FooImpl {...}`  \n`impl Foo for FooImpl { ... the actual work ... }`  \n`impl FooDebug for FooImpl {}`  \n  \nThis feels ugly. The `impl FooDebug for FooImpl {}` especially seems like an extra step that shouldn't be necessary.\n\nAm I missing something, or is this the best and most idiomatic way to do this?",
            "  \nWhat are some OSS projects that are using hyper h2",
            "I've been studying the code of several Rust UI libraries that have functions in the same \"immediate mode\" style. For example, the \\`fn run()\\` is 568 lines with approximately 40 lets and usings at the start of the function before function calls. The deepest whitespace is pretty deep, and the code whitespace looks like a vertical sine wave. Hopefully you get the idea. There's so much code floating around in the vast whitespace ocean that it's not possible to keep track of what the heck is going on nor what depth you are at.\n\nI feel reasonable in looking at this code and saying it stylistically looks awful. But because these are \"state of the art\" rust libraries, I think this would be an unpopular opinion. My guess is this is a natural byproduct of \"immediate mode\" programming, or maybe not having a jitter (designers want to inline everything for performance).\n\nWhat do you think about this?\n\nMaybe I'm just dumb, but I feel valid in saying that publicly-facing API like this will not experience widespread adoption. The only two solutions I see are declarative style API or a jitter to clean up the code, so that function calls can be inlined and performance doesn't suffer. Do you think I can leave comments in Github, or is comments like this not appropriate for a Github project?",
            "(VERY) new to rust, been told to work on an existing rust code base created by a PhD who is new-ish to rust. Part of the code spawns a process via tokio::process::Command::new(fq\\_process\\_name)...\n\nPart of the changes needs me to start up that process manually in another IDE (it is c++) and examine cout and also step through the code.\n\nIs there a way to first attempt to connect to an already-existing process, and if that doesn't exist to simply start it up? That way if I've manually started it I can step through the interaction (via API calls), but if I didn't manually start it the rust codes runs as normal?\n\nI haven't (yet) found a way to create a Child from an already running process.\n\nThanks!",
            "How do I compile just one file. I'm looking for errors and warnings, I don't care about actually generating code.  \nFrom my root directory this command  \n`rustc src/dir/file.rs`  \ndoesn't quite work, because things like `crate::types::foo` tell me  \n`failed to resolve : maybe a missing crate \\`types\\``  \nbut `crate::types` is fine when I'm building the whole crate.  \n\n\nAm I missing something, or is this impossible?",
            "I made a wrapper for accessing bits of information in a byte buffer (headers and payload for networking code via bitvec). First I implemented everything by taking a mutable reference to slice `Packet(&'b mut [u8])`. Now I want to add the possibility for the user to also create this packet from an owned Type like `[u8; N]` or if possible even from everthing that can be deferenced as `&[u8]` like `Vec<u8>`. So I made the type generic, `Packet<T>(T)` , but I have problems to add the correct trait bounds on the impl block, so it can work with `&'b mut [u8]` as well as with an owned type like `[u8; N]`. I played with the `Borrow`, `BorrowMut`, `AsRef` and `AsMut` traits, but could not get something that compiles. \n\nCan you give me a hint how to solve this? Is it even possible without having two separate impl blocks with almost duplicat code? \n\nBonus question: Can I separate the reading functions, which would only need a `&'b [u8]` from the mutating functions, which need a `&'b mut [u8]`, so that when the packet was created from an immutable reference you can only read data, but you can do both reading and writing when it was created from a mutable reference or owned type?",
            "I'm picking up the first edition of the book (ISBN 9781593278281) from my local library soon. Is there anything major that got changed/fixed in the second edition?",
            "Hello fellow Rustaceans.\n\nI'm trying to solve a problem I have with getting a value from a query where the value may not exist. For example, if I'm querying for an email in our user database and the email doesn't exist.\n\nIn this case, I'm using sqlx with the fetch\\_optional method, and returning a Result<Option<MyStruct>, anyhow::Error> from the function. There are two reasons for this:\n\n1. There may not be a value available in the query, but that is not inherently an error in this case.\n2. It didn't make sense to return an error in the instance where we don't necessarily expect a value to be returned.\n\nI'm not sure if this is the \"axiomatic Rust\" way of doing things though. It \\*feels\\* correct, but I'm still a newbie so I could either be wrong or overthinking it.\n\nSo, is this the \"axiomatic Rust\" way of doing things in this instance?",
            "[removed]",
            "How to ensure only single instance of the program is running? And when more instances are spawned, first instance will get notified. No data is passed, the first instance is simply notified that multiple instances attempted to spawn (like a boolean flag) and will consume the notification (i.e. if boolean flag is true, do something and set the boolean flag to false).",
            "I get this compile error whenever I query a json column from my database with sqlx: `unsupported type NULL of column #1 (\"value\")`\n\nI'm not sure why I'm getting it. There's a NOT NULL constraint on the row, it shouldn't be null, right?\n\nHere's the code:\n\n    let id = find_id();\n    let json = sqlx::query!(\"SELECT value FROM json_documents WHERE id = ?\", id)\n        .fetch_optional(&mut *conn)\n        .await?;\n    \n    CREATE TABLE IF NOT EXISTS json_documents (\n        id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n        value JSON NOT NULL\n    );",
            "Did Rust ever move away from trying to make political statements? Rust seems like a fascinating language I would love to learn, but I refuse to learn a language with any notion of political alliance or activism, regardless of the side or stance supported. I saw an article from last year that some leadership changes occurred. Did this correct the problem?",
            "You are right it depends ;)\n\nIt might be helpful to think of errors like ordinary data. Is there a benefit in having many errors variants? E.g. are your users likely to implement error handling strategies depending on the type of error or will they just log it and tell the user to retry?\n\nIs there even anything your library consumers can do? If yes, you should include helpful information in your error type. Let's say your library decodes images and the user tries to decode a PNG image but the data they give you contains a GIF image. Then you can add an enum variant to your error which stores the identified image format. I don't just mean as part of the error message string but a real `ImageFormat` enum stored in the particular enum variant of your error enum. This makes it easy to call your library with the correct configuration options.\n\nOr maybe the input data contains errors. Here it can be helpful to include information about which parts pass validation and which don't.\n\nI'd say these \"recoverable\" errors are the important ones to consider. You can probably put the other errors in a single enum variant because chances are the error is only formatted into a string anyways.",
            "Expose them temporarily?",
            "to clarify, what I'm doing currently is a mix of what I found online + gpt slop. Figured that was better than nothing; the code as a whole compiles, but currently I get a panic in this function because state\\_u64 is spit out as an array of length 2",
            "`state.len()` is just the outer length `NB_1024`, try this:\n\n    std::slice::from_raw_parts_mut(\n        state.as_mut_ptr() as *mut u64,\n        mem::size_of_val(state) / mem::size_of::<u64>(),\n    )\n\n~~By the way this function needs to be marked unsafe because it has the safety condition that the array is aligned to `mem::align_of::<u64>()`.~~\nBy the way you need to `assert!(state.as_mut_ptr().cast::<u64>().is_aligned())` for the `slice::from_raw_parts` to be sound.\nYour git repo is private.",
            "I don't think so, you should look up what GNOME does with its power saver but I'd assume what you need to play with is process priorities.\n\nFor instance I know that on macos a low-priority process will run on the E(fficiency) cores.",
            "Since all of your words are literals, `&'static str` will make a good return type.\n\nIf they are `String`s, you can clone the word and return a `String`.",
            "The web frameworks in Rust (axum, actix_web) can handle an absurd number of connections. They won't be faster that plain tokio, but they will be much easier and not much less performant.",
            "The underlying reason is that shared references are `Copy` while mutable references are not. This means that from `&'short &'long T` you can get a `&'long T` by copying the inner reference, while from `&'short &'long mut T` you can only get a `&'short mut T` with a reborrow.\n\nThe reason is that this would be unsound. If from `&'short &'long mut T` you could get a `&'long mut T`, and you had a `&'long mut T`, you can borrow it as `&'short &'long mut T` then extract a `&'long mut T` from that, then repeat that operation and you got two overlapping `&'long mut T`.",
            "Sure, you can just:\n\n    pub trait FooDebug: Foo + Debug {\n        //\n    }\n    \n    impl<T> FooDebug for T\n    where\n        T: Foo + Debug,\n    {\n        //\n    }",
            "You can implement `FooDebug` for all `T` that implement both `Foo` and `Debug` like this:\n\n    impl<T: Foo + Debug> FooDebug for T {}",
            "I can't speak to the API design concerns, but Rust/LLVM is perfectly capable of inlining most function calls, so I would not expect the absence of JIT optimization to be a relevant factor here.",
            "AFAIK it's not possible to \"reparent\" a process, this has nothing to do with Rust.\n\nHowever it is usually possible to attach debuggers to running processes, so that might be a better option? If you're on linux you can probably also intercept the stdout through `/proc/pid`. Or you can use strace. Or the debugger might be able to handle that after being attached as well.\n\nYou could also update the Rust code to allow attaching to a running process over a socket (network or unix), though that obviously means adding that feature to the program you're running, or at least adding a socket wrapper around it.",
            "> Am I missing something, or is this impossible?\n\nIt's impossible, in that the crate is the unit of compilation in Rust, not the file.\n\nIt's also not really useful, what you're asking is answered by `cargo check`.",
            "To create a `Packet<'a>(&'a mut [u8])` from a `[u8; N]`, all you really need is write something like `Packet(&mut my_array)` provided `my_array` is a value of type `[u8; N]`.",
            "You mean \"idiomatic\"? Certainly yes. Composing `Option` and `Result`s is one of the greatest advantages of them.\n\nSome thought can be given to the order (`Result<Option>` or `Option<Result>`). There is no clear rule here. I tend to use `Result<Option>` where there can be an error or the data may be missing, and `Option<Result>` where the `Option` is more fundamental like \"operation unavailable on ...\" (when this is not an error). The choice is also affected by the ease of `?`ing.",
            "It's probably because you didn't check which subreddit you were posting your question in, you've got the wrong one\n\nr/playrust",
            "I think a file lock is usually used. There's multiple crates, one is [fslock](https://crates.io/crates/fslock).\n\nedit: There have also been previously searchable [discussions on this topic](https://www.reddit.com/r/rust/comments/14hlx8u/a_rusty_way_to_check_if_another_instance_is/). It looks like sometimes sockets are also used.",
            "The leadership changes of last year resulted from failures of communication and of effective organization, rather than anything to do with the making of political statements. Rust's very existence is political, because an extraordinary number of its contributors would be killed if they set foot in a country with the wrong politics, and a software project is inseparable from its contributors. Perhaps there will come a day when everyone in the world will be able to live their lives freely without fear of authoritarian governments and regressive social movements, and on that day perhaps Rust will no longer need to be political.",
            "Hey man, it sounds like this is a problem for you... not for Rust :P \n\nNo one can force you to take a blood pledge to the new hivethink before using Rust.\n\nHeck, if making some political statement is all it takes for them to give me high quality tools for free, then I say, \"more statements, please!\".",
            "The Rust Foundation could make statements about how they worship Hitler's grave and I would still use it because it's a good programming language.\n\nSeriously, grow up...",
            "I will try this out, and yeah I just checked sorry.  IDE settings changed after I updated yesterday I think and I didn't check mb",
            "changed the visibility, if you'd like to go through my code once to see if I'm doing something else wrong on this one. tia",
            "Thank you for your quick reply and the solution.\n\nWould you know where I can read up more about how to use these return types correctly? I am currently reading through [The Rust Programming Language](https://doc.rust-lang.org/book/title-page.html) book, but only up to the end of Chapter 3 and trying to complete the suggested exercises, and have not yet come across return types.",
            "Thanks for the explanation! I hadn\u2019t thought about the impact of the `Copy` trait before. Very helpful!",
            "Thanks! That make things nicer.",
            "Thanks!",
            "Haha yeah, idiomatic. Whoops!\n\nThanks for your response. I'm a JS/PHP dev by trade so Rust is a bit more involved in all kinds of ways, but I'm really enjoying it and want to make sure I'm not bringing any wonky ideas over from those other languages. It really felt like it made sense, so I'm glad I was right!",
            "Cool. Thats all I needed to know",
            "i have sent a pr",
            "References and borrowing are chapter 4 (and a fair amount of learning besides). No idea what exercises you're talking about, early chapters of TRPL only work with numeric values specifically to avoid these issues.",
            "attempted a struct for the state in an earlier version of this but gave up halfway because I couldn't keep track of it reliably when translating ahaha. thank you though, it crashes at the same place but I think I have a better handle on it now"
        ]
    },
    "This Week in Rust #552": {
        "title": "This Week in Rust #552",
        "score": 34,
        "url": "https://this-week-in-rust.org/blog/2024/06/19/this-week-in-rust-552/",
        "content": "",
        "num_comments": 2,
        "comments": [
            "\n# TWIR @ Reddit\n\nHey everyone, here you can follow the r/rust comment threads of articles featured in TWIR (This Week in Rust).\nI've always found it helpful to search for additional insights in the comment section here\nand I hope you can find it helpful too.\nEnjoy !\n\n\n##Official\n- [Announcing Rust 1.79.0 | Rust Blog](http://www.reddit.com/r/rust/comments/1df039t/announcing_rust_1790_rust_blog/) `\u2191553 | 99 comments`\n- [This Development-cycle in Cargo: 1.80 | Inside Rust Blog](http://www.reddit.com/r/rust/comments/1djmy8a/this_developmentcycle_in_cargo_180_inside_rust/) `\u219175 | 1 comment`\n\n##Foundation\n- [Announcing the Safety-Critical Rust Consortium](http://www.reddit.com/r/rust/comments/1defu3q/announcing_the_safetycritical_rust_consortium/) `\u2191145 | 5 comments`\n\n##Newsletters\n- [Meshlets, Stable Interpolation, and Generalized ECS Reactivity with Observers! - This Week in Bevy](http://www.reddit.com/r/rust/comments/1di4wks/meshlets_stable_interpolation_and_generalized_ecs/) `\u219122 | 2 comments`\n\n##Project/Tooling Updates\n- [rust-analyzer changelog #238](http://www.reddit.com/r/rust/comments/1dhqeep/rustanalyzer_changelog_238/) `\u219145 | 11 comments`\n- [Improving LLM code completion performance for Rust.](http://www.reddit.com/r/rust/comments/1df6szs/improving_llm_code_completion_performance_for_rust/) `\u21910 | 0 comment`\n\n##Observations/Thoughts\n- [Path Generics in Rust: A Sketch Proposal for Simplicity and Generality](http://www.reddit.com/r/rust/comments/1deny1r/path_generics_in_rust_a_sketch_proposal_for/) `\u219168 | 13 comments`\n- [Future's liveness problem](http://www.reddit.com/r/rust/comments/1dixhnq/futures_liveness_problem/) `\u219122 | 15 comments`\n- [Optimizing Rust code with Flamegraph and DHAT \u2013 a practical example with Dust DDS](http://www.reddit.com/r/rust/comments/1dexzqf/optimizing_rust_code_with_flamegraph_and_dhat_a/) `\u219123 | 6 comments`\n- [Exograph at the Edge with Cloudflare Workers](http://www.reddit.com/r/rust/comments/1dedjsx/exograph_at_the_edge_with_cloudflare_workers/) `\u21914 | 0 comment`\n- [A Query Compiler, GraphQL Runtime, and Postgres in the browser with WASM](http://www.reddit.com/r/rust/comments/1diwxan/a_query_compiler_graphql_runtime_and_postgres_in/) `\u21910 | 0 comment`\n- [Compiler-Driven Development in Rust](http://www.reddit.com/r/rust/comments/1di1aw4/compilerdriven_development_in_rust/) `\u2191122 | 26 comments`\n- [Rust 1.79.0: Top 10 Most Interesting Things](http://www.reddit.com/r/rust/comments/1dfjwhl/rust_1790_top_10_most_interesting_things/) `\u219116 | 0 comment`\n\n##Rust Walkthroughs\n- [Zero to Performance Hero: How to Benchmark and Profile Your eBPF Code in Rust](http://www.reddit.com/r/rust/comments/1dip6sa/zero_to_performance_hero_how_to_benchmark_and/) `\u21918 | 2 comments`\n- [I explored some different methods for inter-process communication in Rust](http://www.reddit.com/r/rust/comments/1diofg1/i_explored_some_different_methods_for/) `\u2191109 | 27 comments`\n- [\ud83e\udd80 Parsing Python ASTs 20x Faster with Rust](http://www.reddit.com/r/rust/comments/1div01p/parsing_python_asts_20x_faster_with_rust/) `\u219171 | 2 comments`\n- [Making a const version of Rust's array::from_fn - How hard can it be?](http://www.reddit.com/r/rust/comments/1di3rov/making_a_const_version_of_rusts_arrayfrom_fn_how/) `\u219164 | 16 comments`\n- [Using Tauri to build a cross-platform security app](http://www.reddit.com/r/rust/comments/1djn22v/using_tauri_to_build_a_crossplatform_security_app/) `\u21915 | 1 comment`\n- [Generated SDKs for Rust now available on the Buf Schema Registry](http://www.reddit.com/r/rust/comments/1df3xop/generated_sdks_for_rust_now_available_on_the_buf/) `\u21914 | 1 comment`\n\n##Miscellaneous\n- [Rust on social networks in June 2024](http://www.reddit.com/r/rust/comments/1djrqju/rust_on_social_networks_in_june_2024/) `\u219113 | 2 comments`",
            "Somehow the \"Tracking Issues & PRs\" FCP are all RFCs"
        ]
    },
    "AES encryption tutorial": {
        "title": "AES encryption tutorial",
        "score": 15,
        "url": "https://www.reddit.com/r/rust/comments/1dlt7v1/aes_encryption_tutorial/",
        "content": "I wrote a blog demonstrating how to implement AES 128 encryption with cbc from scratch in rust (no libraries) [https://jake-purton.uk/aes-blog/](https://jake-purton.uk/aes-blog/) that people looking for a low level understanding of symmetric encryption may be interested in.",
        "num_comments": 2,
        "comments": [
            "Very well written!",
            "This is great! Neat!"
        ]
    },
    "Making Deno's language server ten times faster (a Node.js alternative written in Rust)": {
        "title": "Making Deno's language server ten times faster (a Node.js alternative written in Rust)",
        "score": 64,
        "url": "https://deno.com/blog/optimizing-our-lsp",
        "content": "",
        "num_comments": 0,
        "comments": []
    },
    "Sudoku solver and generator in rust": {
        "title": "Sudoku solver and generator in rust",
        "score": 14,
        "url": "https://www.reddit.com/r/rust/comments/1dlqv9t/sudoku_solver_and_generator_in_rust/",
        "content": "I have been working on this project since I learned some basic stuff in rust. I am pretty new to rust so anyone is welcome to criticize my bad practices and to improve the code. Here is the link to the repo: [https://github.com/aman333nolawz/Sudoku/tree/rust](https://github.com/aman333nolawz/Sudoku/tree/rust)\n\nhttps://preview.redd.it/jn1nze73138d1.png?width=919&format=png&auto=webp&s=4dc9d09bad099cd922b699a98c0b03896381efb4\n\n",
        "num_comments": 6,
        "comments": [
            "You could probably save yourself one board by having your own type instead of u8. Something like:\n\n```\nenum BoardCell {\n    Initial(u8),\n    Placed(u8),\n    Empty,\n}\n```\n\nThen you can get rid of initial_board and just have board. You could also make the enum optional and ditch the Empty state I put.",
            "Neat! What'd you use for the gui?",
            "You should consider using something like [dancing links](https://youtu.be/_cR9zDlvP88) to generate and solve your puzzles. Your implementation has one major problem right now: your generator can actually generate non-valid puzzles. An important rule for sudoku puzzles to be valid is that they must admit a unique solution. You\u2019re currently brute forcing your solution, so you find the \u201cfirst\u201d solution and ignore any other ones.\n\nAs well, your brute force solution idea will be fine for the most part, but if you ever add the feature for people to manually put in their own puzzles, I\u2019d be able to create an initial puzzle that forced someone\u2019s computer to go through every possibility, and DOS a core on their computer for a while. Also even if you don\u2019t change your solution technique from brute force, consider not using your solution function recursively - this just seems like a poor use of resources.",
            "Thx for the advise. I have now implemented it like this and this is better than the initial\\_board method",
            "I initially started with raylib. But now I use macroquad instead of raylib",
            "I am currently a bit weak on dsa. I have seen dancing links before and thought I am not currently at the level to implement it. I would definitely check it after learning a bit more dsa.\n\nBtw I am pretty sure that my generator creates a valid sudoku which has only one solution . It first fills the cells randomly and then starts subtracting cells randomly and then looks at how much solutions the puzzle has after subtracting a cell. As soon as it has more than 1 solution, the subtraction is stopped and that will be the puzzle board. But this implementation makes it rare to get hard puzzles and puzzles with less clues though and it can be much more fast."
        ]
    }
}